var we = Object.defineProperty;
var ve = (e, t, l) => t in e ? we(e, t, { enumerable: !0, configurable: !0, writable: !0, value: l }) : e[t] = l;
var F = (e, t, l) => (ve(e, typeof t != "symbol" ? t + "" : t, l), l), ae = (e, t, l) => {
  if (!t.has(e))
    throw TypeError("Cannot " + l);
};
var X = (e, t, l) => (ae(e, t, "read from private field"), l ? l.call(e) : t.get(e)), ee = (e, t, l) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, l);
}, te = (e, t, l, a) => (ae(e, t, "write to private field"), a ? a.call(e, l) : t.set(e, l), l);
import { reactive as G, resolveComponent as $, openBlock as s, createBlock as g, Teleport as ke, createVNode as I, TransitionGroup as pe, normalizeClass as f, withCtx as m, createElementBlock as u, Fragment as _, renderList as T, mergeProps as B, createElementVNode as w, createCommentVNode as c, createApp as _e, defineComponent as Ce, inject as Be, withKeys as M, withModifiers as E, renderSlot as p, toHandlers as N, createTextVNode as C, toDisplayString as k, Transition as x, normalizeStyle as L, resolveDynamicComponent as V, normalizeProps as ie, resolveDirective as fe, withDirectives as D, createSlots as Z, vShow as me, vModelText as ge, vModelDynamic as Se, KeepAlive as $e } from "vue";
const Ve = G({
  on: "#app",
  breakpoints: {
    xs: 600,
    sm: 900,
    md: 1200,
    lg: 1700,
    xl: 9999
  },
  css: {
    colorShades: !0,
    breakpointSpaces: !1,
    breakpointLayoutClasses: !0,
    grid: 12
  },
  colors: {
    light: {
      primary: "#234781",
      secondary: "#d3ebff",
      info: "#3d9ff5",
      warning: "#f80",
      success: "#54b946",
      error: "#f65555"
    },
    dark: {
      primary: "#89b6d2",
      secondary: "#375b6a",
      info: "#3d9ff5",
      warning: "#f80",
      success: "#54b946",
      error: "#f65555"
    }
  },
  theme: "light",
  icons: [],
  iconsLigature: !1,
  notificationManager: {
    align: "right",
    transition: "default"
  },
  presets: {}
}), be = (e, t = Ve) => {
  if (!Object.keys(t).length)
    t = Object.assign(t, e);
  else
    for (const l in e) {
      const a = e[l];
      typeof a == "object" ? be(e[l], t[l]) : t[l] = a;
    }
  return t;
}, Ie = ["innerHTML"];
function Re(e, t, l, a, o, i) {
  const n = $("w-alert");
  return s(), g(ke, { to: ".w-app" }, [
    I(pe, {
      class: f(["w-notification-manager", { "w-notification-manager--left": i.conf.align === "left" }]),
      tag: "div",
      name: i.transition,
      appear: ""
    }, {
      default: m(() => [
        (s(!0), u(_, null, T(i.notifications, (r) => (s(), u(_, null, [
          r._value ? (s(), g(n, B({
            class: "white--bg",
            key: r._uid,
            modelValue: r._value,
            "onUpdate:modelValue": (d) => r._value = d,
            onClose: r.dismiss
          }, i.notifProps(r)), {
            default: m(() => [
              w("div", {
                innerHTML: r.message
              }, null, 8, Ie)
            ]),
            _: 2
          }, 1040, ["modelValue", "onUpdate:modelValue", "onClose"])) : c("", !0)
        ], 64))), 256))
      ]),
      _: 1
    }, 8, ["class", "name"])
  ]);
}
const v = (e, t) => {
  const l = e.__vccOpts || e;
  for (const [a, o] of t)
    l[a] = o;
  return l;
}, Le = {
  name: "w-notification-manager",
  computed: {
    conf() {
      return this.$waveui.config.notificationManager;
    },
    notifications() {
      var e;
      return (e = this.$waveui._notificationManager) == null ? void 0 : e.notifications;
    },
    transition() {
      return this.conf.transition ? this.conf.transition.replace("default", `slide-${this.conf.align === "left" ? "right" : "left"}`) : "";
    }
  },
  methods: {
    notifProps(e) {
      const { _value: t, _uid: l, message: a, timeout: o, ...i } = e;
      return i.dismiss && (i.dismiss = !0), i;
    }
  }
}, Te = /* @__PURE__ */ v(Le, [["render", Re]]);
var K;
const H = class {
  constructor() {
    F(this, "notifications");
    F(this, "_uid");
    F(this, "_notificationDefaults");
    if (X(H, K))
      return X(H, K);
    this.notifications = [], this._uid = 0, this._notificationDefaults = {
      _uid: 0,
      _value: !0,
      message: "",
      timeout: 4e3,
      dismiss: !0
    }, te(H, K, this);
  }
  notify(...t) {
    let l = {
      ...this._notificationDefaults,
      _uid: this._uid++
    };
    if (typeof t[0] == "object")
      l = { ...l, ...t[0] };
    else {
      const [a, o, i] = t;
      l = {
        ...l,
        message: a || "",
        [o === void 0 ? "info" : o]: !0,
        timeout: i || i === 0 ? parseFloat(i) : 4e3
      };
    }
    l.dismiss && (l.dismiss = () => this.dismiss(l._uid)), this.notifications.push(l), ~~l.timeout !== 0 && setTimeout(() => this.dismiss(l._uid), l.timeout);
  }
  dismiss(t) {
    this.notifications = this.notifications.filter((l) => l._uid !== t);
  }
};
let Y = H;
K = new WeakMap(), ee(Y, K, void 0);
const xe = (e, t, l) => {
  const a = document.createElement("div");
  e.appendChild(a);
  const o = _e(Ce({
    ...Te,
    inject: ["$waveui"]
  })).provide("$waveui", l);
  for (const i in t) {
    const n = t[i];
    o.component(n.name, { ...n, inject: ["$waveui"] });
  }
  o.mount(a), a.remove();
}, oe = (e, t) => "#" + e.slice(1).match(/../g).map((l) => (l = +`0x${l}` + t, (l < 0 ? 0 : l > 255 ? 255 : l).toString(16).padStart(2, 0))).join(""), Pe = (e) => {
  ["light", "dark"].forEach((t) => {
    const l = e.colors[t];
    l.shades = {};
    for (let a in l) {
      if (a === "shades")
        continue;
      a = { label: a, color: l[a].replace("#", "") };
      const o = a.color;
      o.length === 3 && (a.color = o[0] + "" + o[0] + o[1] + o[1] + o[2] + o[2]);
      for (let i = 1; i <= 3; i++) {
        const n = oe(`#${a.color}`, i * 40), r = oe(`#${a.color}`, -i * 40);
        l.shades[`${a.label}-light${i}`] = n, l.shades[`${a.label}-dark${i}`] = r;
      }
    }
  });
}, ne = (e, t) => {
  const l = {
    ...t.reduce((a, o) => {
      a[o.label] = o.color;
      const i = (o.shades || []).reduce((n, r) => (n[r.label] = r.color, n), {});
      return { ...a, ...i };
    }, { ...e, ...e.shades })
  };
  return delete l.shades, l;
}, re = [
  {
    label: "pink",
    color: "#e91e63",
    shades: [
      { label: "pink-light6", color: "#fdebf1" },
      { label: "pink-light5", color: "#faccdc" },
      { label: "pink-light4", color: "#f7adc6" },
      { label: "pink-light3", color: "#f48eb1" },
      { label: "pink-light2", color: "#f16f9b" },
      { label: "pink-light1", color: "#ee5085" },
      { label: "pink-dark1", color: "#d31555" },
      { label: "pink-dark2", color: "#b6124a" },
      { label: "pink-dark3", color: "#990f3e" },
      { label: "pink-dark4", color: "#7c0c32" },
      { label: "pink-dark5", color: "#600927" },
      { label: "pink-dark6", color: "#43071b" }
    ]
  },
  {
    label: "purple",
    color: "#a741b9",
    shades: [
      { label: "purple-light6", color: "#f9f2fa" },
      { label: "purple-light5", color: "#eed9f2" },
      { label: "purple-light4", color: "#e3c1e9" },
      { label: "purple-light3", color: "#d8a8e1" },
      { label: "purple-light2", color: "#cd90d8" },
      { label: "purple-light1", color: "#c277cf" },
      { label: "purple-dark1", color: "#9239a2" },
      { label: "purple-dark2", color: "#7d318a" },
      { label: "purple-dark3", color: "#682873" },
      { label: "purple-dark4", color: "#53205b" },
      { label: "purple-dark5", color: "#3d1844" },
      { label: "purple-dark6", color: "#28102d" }
    ]
  },
  {
    label: "deep-purple",
    color: "#673ab7",
    shades: [
      { label: "deep-purple-light6", color: "#f1edf9" },
      { label: "deep-purple-light5", color: "#daceef" },
      { label: "deep-purple-light4", color: "#c2afe6" },
      { label: "deep-purple-light3", color: "#ab90dc" },
      { label: "deep-purple-light2", color: "#9471d2" },
      { label: "deep-purple-light1", color: "#7c52c8" },
      { label: "deep-purple-dark1", color: "#5b33a1" },
      { label: "deep-purple-dark2", color: "#4e2c8b" },
      { label: "deep-purple-dark3", color: "#422575" },
      { label: "deep-purple-dark4", color: "#351e5f" },
      { label: "deep-purple-dark5", color: "#291749" },
      { label: "deep-purple-dark6", color: "#1c1033" }
    ]
  },
  {
    label: "indigo",
    color: "#3f51b5",
    shades: [
      { label: "indigo-light6", color: "#eff1fa" },
      { label: "indigo-light5", color: "#d1d6ef" },
      { label: "indigo-light4", color: "#b3bae4" },
      { label: "indigo-light3", color: "#949fda" },
      { label: "indigo-light2", color: "#7684cf" },
      { label: "indigo-light1", color: "#5869c5" },
      { label: "indigo-dark1", color: "#37479f" },
      { label: "indigo-dark2", color: "#303e8a" },
      { label: "indigo-dark3", color: "#283474" },
      { label: "indigo-dark4", color: "#212a5f" },
      { label: "indigo-dark5", color: "#192149" },
      { label: "indigo-dark6", color: "#121734" }
    ]
  },
  {
    label: "blue",
    color: "#2196f3",
    shades: [
      { label: "blue-light6", color: "#e6f3fe" },
      { label: "blue-light5", color: "#c6e4fc" },
      { label: "blue-light4", color: "#a5d4fa" },
      { label: "blue-light3", color: "#84c5f8" },
      { label: "blue-light2", color: "#63b5f7" },
      { label: "blue-light1", color: "#42a6f5" },
      { label: "blue-dark1", color: "#0c85e5" },
      { label: "blue-dark2", color: "#0b72c4" },
      { label: "blue-dark3", color: "#095fa3" },
      { label: "blue-dark4", color: "#074c82" },
      { label: "blue-dark5", color: "#053961" },
      { label: "blue-dark6", color: "#032540" }
    ]
  },
  {
    label: "light-blue",
    color: "#03a9f4",
    shades: [
      { label: "light-blue-light6", color: "#e7f7ff" },
      { label: "light-blue-light5", color: "#c0ebfe" },
      { label: "light-blue-light4", color: "#98defe" },
      { label: "light-blue-light3", color: "#71d2fd" },
      { label: "light-blue-light2", color: "#4ac5fd" },
      { label: "light-blue-light1", color: "#22b9fc" },
      { label: "light-blue-dark1", color: "#0393d5" },
      { label: "light-blue-dark2", color: "#027eb6" },
      { label: "light-blue-dark3", color: "#026896" },
      { label: "light-blue-dark4", color: "#015277" },
      { label: "light-blue-dark5", color: "#013d58" },
      { label: "light-blue-dark6", color: "#012739" }
    ]
  },
  {
    label: "cyan",
    color: "#04cbe5",
    shades: [
      { label: "cyan-light6", color: "#e9fcff" },
      { label: "cyan-light5", color: "#baf6fe" },
      { label: "cyan-light4", color: "#8bf0fd" },
      { label: "cyan-light3", color: "#5ceafc" },
      { label: "cyan-light2", color: "#2ce3fb" },
      { label: "cyan-light1", color: "#04d8f4" },
      { label: "cyan-dark1", color: "#04b2c8" },
      { label: "cyan-dark2", color: "#0398ac" },
      { label: "cyan-dark3", color: "#037f8f" },
      { label: "cyan-dark4", color: "#026673" },
      { label: "cyan-dark5", color: "#024c56" },
      { label: "cyan-dark6", color: "#01333a" }
    ]
  },
  {
    label: "teal",
    color: "#1db3a8",
    shades: [
      { label: "teal-light6", color: "#e2faf9" },
      { label: "teal-light5", color: "#b8f3ef" },
      { label: "teal-light4", color: "#8eede6" },
      { label: "teal-light3", color: "#64e6dc" },
      { label: "teal-light2", color: "#39dfd3" },
      { label: "teal-light1", color: "#20c7bb" },
      { label: "teal-dark1", color: "#199b92" },
      { label: "teal-dark2", color: "#15847c" },
      { label: "teal-dark3", color: "#116c65" },
      { label: "teal-dark4", color: "#0e544f" },
      { label: "teal-dark5", color: "#0a3c39" },
      { label: "teal-dark6", color: "#062523" }
    ]
  },
  {
    label: "green",
    color: "#4caf50",
    shades: [
      { label: "green-light6", color: "#edf7ed" },
      { label: "green-light5", color: "#d2ebd3" },
      { label: "green-light4", color: "#b7e0b8" },
      { label: "green-light3", color: "#9bd49e" },
      { label: "green-light2", color: "#80c883" },
      { label: "green-light1", color: "#65bc69" },
      { label: "green-dark1", color: "#439b47" },
      { label: "green-dark2", color: "#3a863d" },
      { label: "green-dark3", color: "#327234" },
      { label: "green-dark4", color: "#295e2b" },
      { label: "green-dark5", color: "#204a22" },
      { label: "green-dark6", color: "#173518" }
    ]
  },
  {
    label: "light-green",
    color: "#90d73f",
    shades: [
      { label: "light-green-light6", color: "#f4fbec" },
      { label: "light-green-light5", color: "#e5f6d3" },
      { label: "light-green-light4", color: "#d7f1b9" },
      { label: "light-green-light3", color: "#c8eba0" },
      { label: "light-green-light2", color: "#b9e687" },
      { label: "light-green-light1", color: "#abe16d" },
      { label: "light-green-dark1", color: "#80cc2a" },
      { label: "light-green-dark2", color: "#70b225" },
      { label: "light-green-dark3", color: "#609820" },
      { label: "light-green-dark4", color: "#4f7d1a" },
      { label: "light-green-dark5", color: "#3f6315" },
      { label: "light-green-dark6", color: "#2e490f" }
    ]
  },
  {
    label: "lime",
    color: "#cee029",
    shades: [
      { label: "lime-light6", color: "#fafce9" },
      { label: "lime-light5", color: "#f4f8ce" },
      { label: "lime-light4", color: "#edf4b2" },
      { label: "lime-light3", color: "#e7f097" },
      { label: "lime-light2", color: "#e1ec7b" },
      { label: "lime-light1", color: "#dae85f" },
      { label: "lime-dark1", color: "#bbcc1e" },
      { label: "lime-dark2", color: "#a1b01a" },
      { label: "lime-dark3", color: "#889516" },
      { label: "lime-dark4", color: "#6f7912" },
      { label: "lime-dark5", color: "#565d0e" },
      { label: "lime-dark6", color: "#3c420a" }
    ]
  },
  {
    label: "yellow",
    color: "#ffe70f",
    shades: [
      { label: "yellow-light6", color: "#fffce0" },
      { label: "yellow-light5", color: "#fff9c4" },
      { label: "yellow-light4", color: "#fff6a8" },
      { label: "yellow-light3", color: "#fff38c" },
      { label: "yellow-light2", color: "#fff170" },
      { label: "yellow-light1", color: "#ffee54" },
      { label: "yellow-dark1", color: "#eed700" },
      { label: "yellow-dark2", color: "#cfba00" },
      { label: "yellow-dark3", color: "#af9e00" },
      { label: "yellow-dark4", color: "#908100" },
      { label: "yellow-dark5", color: "#706500" },
      { label: "yellow-dark6", color: "#504800" }
    ]
  },
  {
    label: "amber",
    color: "#ffc107",
    shades: [
      { label: "amber-light6", color: "#fffaed" },
      { label: "amber-light5", color: "#fff1c6" },
      { label: "amber-light4", color: "#ffe7a0" },
      { label: "amber-light3", color: "#ffde7a" },
      { label: "amber-light2", color: "#ffd454" },
      { label: "amber-light1", color: "#ffcb2d" },
      { label: "amber-dark1", color: "#e6ad00" },
      { label: "amber-dark2", color: "#c79500" },
      { label: "amber-dark3", color: "#a77d00" },
      { label: "amber-dark4", color: "#886600" },
      { label: "amber-dark5", color: "#684e00" },
      { label: "amber-dark6", color: "#483600" }
    ]
  },
  {
    label: "orange",
    color: "#ff9800",
    shades: [
      { label: "orange-light6", color: "#fff5e6" },
      { label: "orange-light5", color: "#ffe5bf" },
      { label: "orange-light4", color: "#ffd699" },
      { label: "orange-light3", color: "#ffc673" },
      { label: "orange-light2", color: "#ffb74d" },
      { label: "orange-light1", color: "#ffa726" },
      { label: "orange-dark1", color: "#df8500" },
      { label: "orange-dark2", color: "#c07200" },
      { label: "orange-dark3", color: "#a05f00" },
      { label: "orange-dark4", color: "#814d00" },
      { label: "orange-dark5", color: "#613a00" },
      { label: "orange-dark6", color: "#412700" }
    ]
  },
  {
    label: "deep-orange",
    color: "#ff6825",
    shades: [
      { label: "deep-orange-light6", color: "#fff0e9" },
      { label: "deep-orange-light5", color: "#ffd9c8" },
      { label: "deep-orange-light4", color: "#ffc2a8" },
      { label: "deep-orange-light3", color: "#ffac87" },
      { label: "deep-orange-light2", color: "#ff9566" },
      { label: "deep-orange-light1", color: "#ff7f46" },
      { label: "deep-orange-dark1", color: "#ff5205" },
      { label: "deep-orange-dark2", color: "#e54600" },
      { label: "deep-orange-dark3", color: "#c53d00" },
      { label: "deep-orange-dark4", color: "#a63300" },
      { label: "deep-orange-dark5", color: "#862900" },
      { label: "deep-orange-dark6", color: "#661f00" }
    ]
  },
  {
    label: "red",
    color: "#fa3317",
    shades: [
      { label: "red-light6", color: "#fee3df" },
      { label: "red-light5", color: "#fec6be" },
      { label: "red-light4", color: "#fdaa9e" },
      { label: "red-light3", color: "#fc8d7d" },
      { label: "red-light2", color: "#fc705d" },
      { label: "red-light1", color: "#fb543c" },
      { label: "red-dark1", color: "#ec2205" },
      { label: "red-dark2", color: "#cd1d04" },
      { label: "red-dark3", color: "#ae1904" },
      { label: "red-dark4", color: "#8f1403" },
      { label: "red-dark5", color: "#701002" },
      { label: "red-dark6", color: "#520c02" }
    ]
  },
  {
    label: "brown",
    color: "#845848",
    shades: [
      { label: "brown-light6", color: "#f2eae7" },
      { label: "brown-light5", color: "#e2d1ca" },
      { label: "brown-light4", color: "#d2b7ad" },
      { label: "brown-light3", color: "#c39e90" },
      { label: "brown-light2", color: "#b38473" },
      { label: "brown-light1", color: "#a16b58" },
      { label: "brown-dark1", color: "#744d3f" },
      { label: "brown-dark2", color: "#634236" },
      { label: "brown-dark3", color: "#53372d" },
      { label: "brown-dark4", color: "#422c24" },
      { label: "brown-dark5", color: "#32211b" },
      { label: "brown-dark6", color: "#211612" }
    ]
  },
  {
    label: "blue-grey",
    color: "#6c8693",
    shades: [
      { label: "blue-grey-light6", color: "#f0f3f4" },
      { label: "blue-grey-light5", color: "#dae1e4" },
      { label: "blue-grey-light4", color: "#c4cfd4" },
      { label: "blue-grey-light3", color: "#aebcc4" },
      { label: "blue-grey-light2", color: "#98aab3" },
      { label: "blue-grey-light1", color: "#8298a3" },
      { label: "blue-grey-dark1", color: "#5f7581" },
      { label: "blue-grey-dark2", color: "#51656f" },
      { label: "blue-grey-dark3", color: "#44545c" },
      { label: "blue-grey-dark4", color: "#36444a" },
      { label: "blue-grey-dark5", color: "#293338" },
      { label: "blue-grey-dark6", color: "#1c2226" }
    ]
  },
  {
    label: "grey",
    color: "#848484",
    shades: [
      { label: "grey-light6", color: "#f7f7f7" },
      { label: "grey-light5", color: "#e4e4e4" },
      { label: "grey-light4", color: "#d1d1d1" },
      { label: "grey-light3", color: "#bdbdbd" },
      { label: "grey-light2", color: "#aaaaaa" },
      { label: "grey-light1", color: "#979797" },
      { label: "grey-dark1", color: "#747474" },
      { label: "grey-dark2", color: "#646464" },
      { label: "grey-dark3", color: "#555555" },
      { label: "grey-dark4", color: "#454545" },
      { label: "grey-dark5", color: "#353535" },
      { label: "grey-dark6", color: "#252525" }
    ]
  },
  { label: "black", color: "#000" },
  { label: "white", color: "#fff" },
  { label: "transparent", color: "transparent" },
  { label: "inherit", color: "inherit" }
], U = {
  cssScope: ".w-app",
  baseIncrement: 4
};
let se = { keys: [], values: [] }, de = null;
const Oe = (e) => {
  let t = "";
  const l = {}, { info: a, warning: o, success: i, error: n, shades: r, ...d } = e, { cssScope: h } = U;
  for (const b in d)
    t += `${h} .${b}--bg{background-color:var(--w-${b}-color)}${h} .${b}{color:var(--w-${b}-color)}`;
  for (const b in r)
    t += `${h} .${b}--bg{background-color:${r[b]}}${h} .${b}{color:${r[b]}}`;
  const y = { ...d, info: a, warning: o, success: i, error: n };
  for (const b in y)
    l[b] = y[b];
  let S = "";
  return Object.entries(l).forEach(([b, R]) => {
    S += `--w-${b}-color: ${R};`;
  }), `:root{${S}}${t}`;
}, ze = (e, t) => {
  let l = "";
  const { cssScope: a } = U;
  return e.forEach(({ min: o, label: i }) => {
    if (i === "xs")
      for (let n = 0; n < t; n++)
        l += `${a} .${i}${t - n}{width:${parseFloat(((t - n) * 100 / t).toFixed(4))}%;}`;
    else {
      l += `@media(min-width:${o}px){`;
      for (let n = 0; n < t; n++)
        l += `${a} .${i}${t - n}{width:${parseFloat(((t - n) * 100 / t).toFixed(4))}%;}`;
      l += "}";
    }
  }), l;
}, Ee = (e) => {
  let t = "";
  const { cssScope: l, baseIncrement: a } = U, o = [
    "show{display:block}",
    "hide{display:none}",
    "d-flex{display:flex}",
    "d-iflex{display:inline-flex}",
    "d-block{display:block}",
    "d-iblock{display:inline-block}",
    "text-left{text-align:left}",
    "text-center{text-align:center}",
    "text-right{text-align:right}",
    "text-nowrap{white-space:nowrap}",
    "row{flex-direction:row}",
    "column{flex-direction:column}",
    "grow{flex-grow:1;flex-basis:auto}",
    "no-grow{flex-grow:0}",
    "shrink{flex-shrink:1;margin-left:auto;margin-right:auto}",
    "no-shrink{flex-shrink:0}",
    "fill-width{width:100%}",
    "fill-height{height:100%}",
    "basis-zero{flex-basis:0}",
    "align-start{align-items:flex-start}",
    "align-center{align-items:center}",
    "align-end{align-items:flex-end}",
    "align-self-start{align-self:flex-start}",
    "align-self-center{align-self:center}",
    "align-self-end{align-self:flex-end}",
    "align-self-stretch{align-self:stretch}",
    "justify-start{justify-content:flex-start}",
    "justify-center{justify-content:center}",
    "justify-end{justify-content:flex-end}",
    "justify-space-between{justify-content:space-between}",
    "justify-space-around{justify-content:space-around}",
    "justify-space-evenly{justify-content:space-evenly}"
  ], i = Array(12).fill();
  return e.forEach(({ label: n, min: r }) => {
    n !== "xs" && (t += `@media(min-width:${r}px){` + o.map((d) => `${l} .${n}u-${d}`).join("") + i.map((d, h) => `.w-grid.${n}u-columns${h + 1}{grid-template-columns:repeat(${h + 1},1fr);}`).join("") + i.map((d, h) => `.w-flex.${n}u-gap${h + 1},.w-grid.${n}u-gap${h + 1}{gap:${(h + 1) * a}px;}`).join("") + `.w-flex.${n}u-gap0,.w-flex.${n}u-gap0{gap:0}}`);
  }), e.forEach(({ label: n, min: r, max: d }) => {
    t += `@media (min-width:${r}px) and (max-width:${d}px){` + o.map((h) => `${l} .${n}-${h}`).join("") + i.map((h, y) => `.w-grid.${n}-columns${y + 1}{grid-template-columns:repeat(${y + 1},1fr);}`).join("") + i.map((h, y) => `.w-flex.${n}-gap${y + 1},.w-grid.${n}-gap${y + 1}{gap:${(y + 1) * a}px;}`).join("") + `.w-flex.${n}-gap0,.w-flex.${n}-gap0{gap:0}}`;
  }), e.forEach(({ label: n, max: r }) => {
    n !== "xl" && (t += `@media (max-width:${r}px){` + o.map((d) => `${l} .${n}d-${d}`).join("") + i.map((d, h) => `.w-grid.${n}d-columns${h + 1}{grid-template-columns:repeat(${h + 1},1fr);}`).join("") + i.map((d, h) => `.w-flex.${n}d-gap${h + 1},.w-grid.${n}d-gap${h + 1}{gap:${(h + 1) * a}px;}`).join("") + `.w-flex.${n}d-gap0,.w-flex.${n}d-gap0{gap:0}}`);
  }), t;
}, ue = (e) => {
  const t = window.innerWidth, l = se.values.slice(0);
  l.push(t), l.sort((o, i) => o - i);
  const a = se.keys[l.indexOf(t)] || "xl";
  a !== de && (de = a, e.breakpoint = {
    name: a,
    xs: a === "xs",
    sm: a === "sm",
    md: a === "md",
    lg: a === "lg",
    xl: a === "xl",
    width: t
  }), e.breakpoint.width = window.innerWidth;
}, Me = (e) => {
  const { config: t } = e;
  if (se = { keys: Object.keys(t.breakpoints), values: Object.values(t.breakpoints) }, !document.getElementById("wave-ui-styles")) {
    const l = document.createElement("style");
    l.id = "wave-ui-styles", l.innerHTML = We(t);
    const a = document.head.querySelectorAll('style,link[rel="stylesheet"]')[0];
    a ? a.before(l) : document.head.appendChild(l);
  }
  ue(e), window.addEventListener("resize", () => ue(e));
}, Ne = (e) => {
  if (!document.getElementById("wave-ui-colors")) {
    const t = document.createElement("style");
    t.id = "wave-ui-colors", t.innerHTML = Oe(e);
    const l = document.head.querySelectorAll('style,link[rel="stylesheet"]')[0];
    l ? l.before(t) : document.head.appendChild(t);
  }
}, We = (e) => {
  const t = Object.entries(e.breakpoints), l = t.map(([i, n], r) => {
    const [, d = 0] = t[r - 1] || [];
    return { label: i, min: d ? d + 1 : 0, max: n };
  }), a = getComputedStyle(document.documentElement);
  U.cssScope = a.getPropertyValue("--w-css-scope"), U.baseIncrement = parseInt(a.getPropertyValue("--w-base-increment"));
  let o = "";
  return o += ze(l, e.css.grid), e.css.breakpointLayoutClasses && (o += Ee(l)), o;
};
let he = !1;
const Ae = (e) => {
  const t = window.matchMedia("(prefers-color-scheme: dark)");
  e.preferredTheme = t.matches ? "dark" : "light", e.switchTheme(e.preferredTheme), t.addEventListener("change", (l) => {
    e.preferredTheme = l.matches ? "dark" : "light", e.switchTheme(e.preferredTheme);
  });
}, Ke = (e, t) => {
  for (const l in t)
    e.props[l].default = t[l];
};
var q;
const j = class {
  constructor(t, l = {}) {
    F(this, "$waveui", {
      breakpoint: {
        name: "",
        xs: !1,
        sm: !1,
        md: !1,
        lg: !1,
        xl: !1,
        width: null
      },
      config: {},
      colors: {},
      preferredTheme: null,
      theme: null,
      _notificationManager: null,
      notify(...t) {
        this._notificationManager.notify(...t);
      },
      switchTheme(t, l = !1) {
        var o, i;
        this.theme = t, document.documentElement.setAttribute("data-theme", t), (i = (o = document.head.querySelector("#wave-ui-colors")) == null ? void 0 : o.remove) == null || i.call(o);
        const a = this.config.colors[this.theme];
        Ne(a), this.colors = ne(a, re);
      }
    });
    if (X(j, q)) {
      console.warn("Wave UI is already instantiated.");
      return;
    }
    if (this.$waveui._notificationManager = new Y(), l.theme || (l.theme = "light"), l.colors) {
      const n = { ...l.colors };
      l.colors.light || (l.colors.light = n), l.colors.dark || (l.colors.dark = n), l.colors = { light: l.colors.light, dark: l.colors.dark };
    }
    let { components: a, ...o } = l;
    o = this.$waveui.config = be(o), o.css.colorShades && Pe(o);
    const i = G(this.$waveui);
    t.config.globalProperties.$waveui = i, t.provide("$waveui", i), o.theme !== "auto" && (this.$waveui.colors = ne(o.colors[o.theme], re));
  }
  static install(t, l = {}) {
    var o;
    t.directive("focus", {
      mounted: (i) => setTimeout(() => i.focus(), 0)
    }), t.directive("scroll", {
      mounted: (i, n) => {
        const r = (d) => {
          n.value(d, i) && window.removeEventListener("scroll", r);
        };
        window.addEventListener("scroll", r);
      }
    });
    const { components: a = {} } = l || {};
    for (const i in a) {
      const n = a[i];
      (o = l.presets) != null && o[n.name] && Ke(n, l.presets[n.name]), t.component(n.name, n);
    }
    t.mixin({
      beforeMount() {
        if (!he) {
          he = !0;
          const i = Be("$waveui"), { config: n } = i, r = document.querySelector(n.on) || document.body;
          r.classList.add("w-app"), n.theme === "auto" ? Ae(i) : i.switchTheme(n.theme, !0), Me(i), xe(r, a, i), t._context.mixins.find((d) => d.mounted && delete d.mounted);
        }
      }
    }), new j(t, l), te(j, q, !0);
  }
};
let A = j;
q = new WeakMap(), ee(A, q, !1);
const De = ["aria-expanded"], Fe = ["onClick", "onFocus", "onKeypress", "tabindex"], He = ["innerHTML"], je = ["innerHTML"];
function Ue(e, t, l, a, o, i) {
  const n = $("w-button"), r = $("w-transition-expand");
  return s(), u("div", {
    class: f(["w-accordion", i.accordionClasses])
  }, [
    (s(!0), u(_, null, T(e.accordionItems, (d, h) => (s(), u("div", {
      class: f(["w-accordion__item", i.itemClasses(d)]),
      key: h,
      "aria-expanded": d._expanded ? "true" : "false"
    }, [
      w("div", {
        class: f(["w-accordion__item-title", l.titleClass]),
        onClick: (y) => !d._disabled && i.toggleItem(d, y),
        onFocus: (y) => e.$emit("focus", i.getOriginalItem(d)),
        onKeypress: M((y) => !d._disabled && i.toggleItem(d, y), ["enter"]),
        tabindex: !d._disabled && 0
      }, [
        l.expandIcon && !l.expandIconRight ? (s(), g(n, {
          key: 0,
          class: f(["w-accordion__expand-icon", { "w-accordion__expand-icon--expanded": d._expanded, "w-accordion__expand-icon--rotate90": l.expandIconRotate90 }]),
          icon: d._expanded && l.collapseIcon || l.expandIcon,
          "icon-props": l.expandIconProps,
          disabled: d._disabled || null,
          tabindex: -1,
          text: "",
          onKeypress: t[0] || (t[0] = E(() => {
          }, ["stop"])),
          onClick: E((y) => !d._disabled && i.toggleItem(d, y), ["stop"])
        }, null, 8, ["icon", "icon-props", "disabled", "onClick", "class"])) : c("", !0),
        e.$slots[`item-title.${d.id || h + 1}`] ? p(e.$slots, `item-title.${d.id || h + 1}`, {
          key: 1,
          item: i.getOriginalItem(d),
          expanded: d._expanded,
          index: h + 1
        }) : p(e.$slots, "item-title", {
          key: 2,
          item: i.getOriginalItem(d),
          expanded: d._expanded,
          index: h + 1
        }, () => [
          w("div", {
            class: "grow",
            innerHTML: d[l.itemTitleKey]
          }, null, 8, He)
        ]),
        l.expandIcon && l.expandIconRight ? (s(), g(n, {
          key: 3,
          class: f(["w-accordion__expand-icon", { "w-accordion__expand-icon--expanded": d._expanded, "w-accordion__expand-icon--rotate90": l.expandIconRotate90 }]),
          icon: d._expanded && l.collapseIcon || l.expandIcon,
          text: "",
          onKeypress: t[1] || (t[1] = E(() => {
          }, ["stop"])),
          onClick: E((y) => !d._disabled && i.toggleItem(d, y), ["stop"])
        }, null, 8, ["icon", "onClick", "class"])) : c("", !0)
      ], 42, Fe),
      I(r, {
        y: "",
        onAfterLeave: (y) => i.onEndOfCollapse(d),
        duration: l.duration
      }, {
        default: m(() => [
          d._expanded ? (s(), u("div", {
            key: 0,
            class: f(["w-accordion__item-content", l.contentClass])
          }, [
            e.$slots[`item-content.${d.id || h + 1}`] ? p(e.$slots, `item-content.${d.id || h + 1}`, {
              key: 0,
              item: i.getOriginalItem(d),
              expanded: d._expanded,
              index: h + 1
            }) : p(e.$slots, "item-content", {
              key: 1,
              item: i.getOriginalItem(d),
              expanded: d._expanded,
              index: h + 1
            }, () => [
              w("div", {
                innerHTML: d[l.itemContentKey]
              }, null, 8, je)
            ])
          ], 2)) : c("", !0)
        ]),
        _: 2
      }, 1032, ["onAfterLeave", "duration"])
    ], 10, De))), 128))
  ], 2);
}
const qe = {
  name: "w-accordion",
  props: {
    modelValue: { type: Array },
    color: { type: String },
    bgColor: { type: String },
    items: { type: [Array, Number], required: !0 },
    itemColorKey: { type: String, default: "color" },
    itemTitleKey: { type: String, default: "title" },
    itemContentKey: { type: String, default: "content" },
    itemClass: { type: String },
    titleClass: { type: String },
    contentClass: { type: String },
    expandIcon: { type: [String, Boolean], default: "wi-triangle-down" },
    expandIconRight: { type: Boolean },
    expandIconRotate90: { type: Boolean },
    expandIconProps: { type: Object, default: () => ({}) },
    expandSingle: { type: Boolean },
    collapseIcon: { type: String },
    shadow: { type: Boolean },
    duration: { type: Number, default: 250 },
    dark: { type: Boolean },
    light: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "focus", "item-expand", "item-collapsed"],
  data: () => ({
    accordionItems: []
  }),
  computed: {
    accordionClasses() {
      return {
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor,
        "w-accordion--dark": this.dark,
        "w-accordion--light": this.light,
        "w-accordion--shadow": this.shadow,
        "w-accordion--no-icon": !this.expandIcon && !this.collapseIcon,
        "w-accordion--icon-right": this.expandIcon && this.expandIconRight,
        "w-accordion--rotate-icon": this.expandIcon && !this.collapseIcon
      };
    }
  },
  methods: {
    toggleItem(e, t) {
      e._expanded = !e._expanded, this.expandSingle && this.accordionItems.forEach((a) => a._index !== e._index && (a._expanded = !1));
      const l = this.accordionItems.map((a) => a._expanded || !1);
      this.$emit("update:modelValue", l), this.$emit("input", l), this.$emit("item-expand", { item: e, expanded: e._expanded }), t.target.blur(), setTimeout(() => t.target.focus(), 300);
    },
    onEndOfCollapse(e) {
      this.$emit("item-collapsed", { item: e, expanded: e._expanded });
    },
    getOriginalItem(e) {
      return this.items[e._index];
    },
    itemClasses(e) {
      return {
        [this.itemClass]: this.itemClass || null,
        "w-accordion__item--expanded": e._expanded,
        "w-accordion__item--disabled": e._disabled,
        [e[this.itemColorKey]]: e[this.itemColorKey]
      };
    },
    updateItems() {
      const e = typeof this.items == "number" ? Array(this.items).fill({}) : this.items || [];
      this.accordionItems = e.map((t, l) => ({
        ...t,
        _index: l,
        _expanded: this.modelValue && this.modelValue[l],
        _disabled: !!t.disabled
      }));
    }
  },
  created() {
    this.updateItems();
  },
  watch: {
    modelValue() {
      this.updateItems();
    },
    items: {
      handler() {
        this.updateItems();
      },
      deep: !0
    }
  }
}, Ge = /* @__PURE__ */ v(qe, [["render", Ue]]), Xe = { class: "w-alert__content" };
function Ye(e, t, l, a, o, i) {
  const n = $("w-icon"), r = $("w-button");
  return o.show ? (s(), u("div", B({
    key: 0,
    class: "w-alert"
  }, N(e.$attrs, !0), { class: i.classes }), [
    i.type || l.icon || l.dismiss ? (s(), u(_, { key: 0 }, [
      i.type || l.icon ? (s(), g(n, {
        key: 0,
        class: "w-alert__icon mr2"
      }, {
        default: m(() => [
          C(k(i.type ? i.typeIcon : l.icon), 1)
        ]),
        _: 1
      })) : c("", !0),
      w("div", Xe, [
        p(e.$slots, "default")
      ]),
      l.dismiss ? (s(), g(r, {
        key: 1,
        class: "w-alert__dismiss",
        onClick: t[0] || (t[0] = (d) => {
          e.$emit("update:modelValue", o.show = !1), e.$emit("input", !1), e.$emit("close", !1);
        }),
        icon: "wi-cross",
        color: "inherit",
        sm: "",
        text: ""
      })) : c("", !0)
    ], 64)) : p(e.$slots, "default", { key: 1 })
  ], 16)) : c("", !0);
}
const Je = {
  name: "w-alert",
  props: {
    modelValue: { default: !0 },
    color: { type: String },
    bgColor: { type: String },
    shadow: { type: Boolean },
    tile: { type: Boolean },
    round: { type: Boolean },
    icon: { type: String },
    iconOutside: { type: Boolean },
    plain: { type: Boolean },
    dismiss: { type: Boolean },
    success: { type: Boolean },
    info: { type: Boolean },
    warning: { type: Boolean },
    error: { type: Boolean },
    xs: { type: Boolean },
    sm: { type: Boolean },
    md: { type: Boolean },
    lg: { type: Boolean },
    xl: { type: Boolean },
    noBorder: { type: Boolean },
    borderLeft: { type: Boolean },
    borderRight: { type: Boolean },
    borderTop: { type: Boolean },
    borderBottom: { type: Boolean },
    outline: { type: Boolean },
    dark: { type: Boolean },
    light: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "close"],
  data() {
    return {
      show: this.modelValue
    };
  },
  computed: {
    typeIcon() {
      return this.type === "success" && "wi-check-circle" || this.type === "warning" && "wi-warning-circle" || this.type === "error" && "wi-cross-circle" || this.type === "info" && "wi-info-circle";
    },
    type() {
      return this.success && "success" || this.info && "info" || this.warning && "warning" || this.error && "error" || null;
    },
    presetSize() {
      return this.xs && "xs" || this.sm && "sm" || this.md && "md" || this.lg && "lg" || this.xl && "xl" || null;
    },
    hasSingleBorder() {
      return this.borderLeft || this.borderRight || this.borderTop || this.borderBottom;
    },
    classes() {
      return {
        [`${this.bgColor || this.plain && this.type}--bg w-alert--bg`]: this.bgColor || this.plain && this.type,
        [this.color || !this.plain && this.type]: this.color || !this.plain && this.type,
        [`size--${this.presetSize}`]: this.presetSize,
        [`w-alert--${this.type}`]: this.type,
        "w-alert--has-icon": this.type || this.icon || this.dismiss,
        "w-alert--icon-outside": this.iconOutside,
        "w-alert--plain": this.type && this.plain,
        "w-alert--outline": this.outline,
        "w-alert--tile": this.tile,
        "w-alert--round": this.round,
        "w-alert--no-border": this.noBorder || this.plain && this.type,
        "w-alert--one-border": this.hasSingleBorder || this.iconOutside,
        "w-alert--border-left": !this.noBorder && this.borderLeft || this.iconOutside,
        "w-alert--border-right": !this.noBorder && this.borderRight,
        "w-alert--border-top": !this.noBorder && this.borderTop,
        "w-alert--border-bottom": !this.noBorder && this.borderBottom,
        "w-alert--shadow": this.shadow,
        "w-alert--dark": this.dark,
        "w-alert--light": this.light
      };
    }
  },
  watch: {
    modelValue(e) {
      this.show = e;
    }
  }
}, Qe = /* @__PURE__ */ v(Je, [["render", Ye]]), Ze = { class: "w-app" };
function et(e, t, l, a, o, i) {
  return s(), u("div", Ze, [
    p(e.$slots, "default")
  ]);
}
const tt = {
  name: "w-app",
  props: {
    block: { type: Boolean },
    row: { type: Boolean },
    alignCenter: { type: Boolean },
    alignEnd: { type: Boolean },
    justifyCenter: { type: Boolean },
    justifyEnd: { type: Boolean },
    justifySpaceBetween: { type: Boolean },
    justifySpaceAround: { type: Boolean },
    justifySpaceEvenly: { type: Boolean },
    textCenter: { type: Boolean },
    textRight: { type: Boolean }
  }
}, lt = /* @__PURE__ */ v(tt, [["render", et]]);
function it(e, t, l, a, o, i) {
  return s(), u("div", B({ class: "w-badge-wrap" }, N(e.$attrs, !0)), [
    p(e.$slots, "default"),
    I(x, {
      name: `${l.transition}`
    }, {
      default: m(() => [
        l.modelValue ? (s(), u("div", {
          key: 0,
          class: f(["w-badge", i.classes]),
          style: L(i.styles),
          "aria-atomic": "true",
          "aria-label": "Badge",
          "aria-live": "polite",
          role: "status"
        }, [
          l.dot ? c("", !0) : p(e.$slots, "badge", { key: 0 }, () => [
            C(k(l.modelValue === !0 ? "" : l.modelValue || ""), 1)
          ])
        ], 6)) : c("", !0)
      ]),
      _: 3
    }, 8, ["name"])
  ], 16);
}
const st = {
  name: "w-badge",
  props: {
    modelValue: { default: !0 },
    xs: { type: Boolean },
    sm: { type: Boolean },
    md: { type: Boolean },
    lg: { type: Boolean },
    xl: { type: Boolean },
    top: { type: Boolean },
    left: { type: Boolean },
    right: { type: Boolean },
    bottom: { type: Boolean },
    overlap: { type: Boolean },
    inline: { type: Boolean },
    color: { type: String },
    size: { type: [Number, String] },
    bgColor: { type: String, default: "primary" },
    badgeClass: { type: String },
    outline: { type: Boolean },
    shadow: { type: Boolean },
    dot: { type: Boolean },
    round: { type: Boolean },
    transition: { type: String, default: "fade" },
    dark: { type: Boolean },
    light: { type: Boolean }
  },
  emits: [],
  computed: {
    forcedSize() {
      return this.size && (isNaN(this.size) ? this.size : `${this.size}px`);
    },
    presetSize() {
      return this.xs && "xs" || this.sm && "sm" || this.md && "md" || this.lg && "lg" || this.xl && "xl" || "md";
    },
    position() {
      return [
        this.top && "top" || this.bottom && "bottom" || "top",
        this.left && "left" || this.right && "right" || "right"
      ];
    },
    classes() {
      const e = this.$slots.badge && this.$slots.badge().map((t) => t.children).join("");
      return {
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor,
        [this.badgeClass]: this.badgeClass || null,
        "w-badge--round": this.round || (e || this.modelValue + "" || "").length < 2,
        "w-badge--dark": this.dark,
        "w-badge--light": this.light,
        "w-badge--outline": this.outline,
        "w-badge--inline": this.inline,
        "w-badge--shadow": this.shadow,
        "w-badge--overlap": this.overlap,
        "w-badge--dot": this.dot,
        [`size--${this.presetSize}`]: this.presetSize && !this.forcedSize,
        [`w-badge--${this.position.join(" w-badge--")}`]: !0
      };
    },
    styles() {
      return this.forcedSize && `font-size: ${this.forcedSize}`;
    }
  }
}, at = /* @__PURE__ */ v(st, [["render", it]]), ot = ["innerHTML"];
function nt(e, t, l, a, o, i) {
  const n = $("w-icon");
  return s(), u("div", {
    class: f(["w-breadcrumbs", i.classes])
  }, [
    (s(!0), u(_, null, T(l.items, (r, d) => (s(), u(_, null, [
      d && e.$slots.separator ? (s(), u("span", {
        class: f(["w-breadcrumbs__separator", l.separatorColor]),
        key: `${d}a`
      }, [
        p(e.$slots, "separator", { index: d })
      ], 2)) : d ? (s(), g(n, {
        class: f(["w-breadcrumbs__separator", l.separatorColor]),
        key: `${d}b`
      }, {
        default: m(() => [
          C(k(l.icon), 1)
        ]),
        _: 2
      }, 1032, ["class"])) : c("", !0),
      r[l.itemRouteKey] && (d < l.items.length - 1 || l.linkLastItem) ? (s(), u(_, { key: 2 }, [
        e.$slots.item ? (s(), g(V(i.hasRouter ? "router-link" : "a"), {
          class: f(["w-breadcrumbs__item", l.color || null]),
          key: `${d}c`,
          to: i.hasRouter && r[l.itemRouteKey],
          href: r[l.itemRouteKey]
        }, {
          default: m(() => [
            p(e.$slots, "item", {
              item: r,
              index: d + 1,
              isLast: d === l.items.length - 1
            })
          ]),
          _: 2
        }, 1032, ["to", "href", "class"])) : (s(), g(V(i.hasRouter ? "router-link" : "a"), {
          class: f(["w-breadcrumbs__item", l.color || null]),
          key: `${d}d`,
          to: i.hasRouter && r[l.itemRouteKey],
          href: r[l.itemRouteKey],
          innerHTML: r[l.itemLabelKey]
        }, null, 8, ["to", "href", "innerHTML", "class"]))
      ], 64)) : e.$slots.item ? p(e.$slots, "item", {
        key: `${d}e`,
        item: r,
        index: d + 1,
        isLast: d === l.items.length - 1
      }) : (s(), u("span", {
        key: `${d}f`,
        innerHTML: r[l.itemLabelKey]
      }, null, 8, ot))
    ], 64))), 256))
  ], 2);
}
const rt = {
  name: "w-breadcrumbs",
  props: {
    items: { type: Array, required: !0 },
    linkLastItem: { type: Boolean },
    color: { type: String },
    separatorColor: { type: String, default: "grey-light1" },
    icon: { type: String, default: "wi-chevron-right" },
    itemRouteKey: { type: String, default: "route" },
    itemLabelKey: { type: String, default: "label" },
    xs: { type: Boolean },
    sm: { type: Boolean },
    md: { type: Boolean },
    lg: { type: Boolean },
    xl: { type: Boolean }
  },
  emits: [],
  computed: {
    hasRouter() {
      return "$router" in this;
    },
    size() {
      return this.xs && "xs" || this.sm && "sm" || this.lg && "lg" || this.xl && "xl" || "md";
    },
    classes() {
      return {
        [`size--${this.size}`]: !0
      };
    }
  }
}, dt = /* @__PURE__ */ v(rt, [["render", nt]]), ut = {
  key: 0,
  class: "w-button__loader"
}, ht = /* @__PURE__ */ w("svg", { viewBox: "0 0 40 40" }, [
  /* @__PURE__ */ w("circle", {
    cx: "20",
    cy: "20",
    r: "18",
    fill: "transparent",
    stroke: "currentColor",
    "stroke-width": "4",
    "stroke-linecap": "round"
  })
], -1);
function ct(e, t, l, a, o, i) {
  const n = $("w-icon");
  return s(), g(V(l.route ? "a" : "button"), B({
    class: ["w-button", i.classes],
    type: !l.route && l.type,
    href: l.route && (i.externalLink ? l.route : i.resolvedRoute) || null,
    disabled: !!l.disabled || null
  }, N(i.listeners), { style: i.styles }), {
    default: m(() => [
      l.icon ? (s(), g(n, ie(B({ key: 0 }, l.iconProps || {})), {
        default: m(() => [
          C(k(l.icon), 1)
        ]),
        _: 1
      }, 16)) : p(e.$slots, "default", { key: 1 }),
      I(x, { name: "scale-fade" }, {
        default: m(() => [
          l.loading ? (s(), u("div", ut, [
            p(e.$slots, "loading", {}, () => [
              ht
            ])
          ])) : c("", !0)
        ]),
        _: 3
      })
    ]),
    _: 3
  }, 16, ["type", "href", "class", "disabled", "style"]);
}
const pt = {
  props: {
    color: { type: String },
    bgColor: { type: String },
    dark: { type: Boolean },
    light: { type: Boolean },
    outline: { type: Boolean },
    text: { type: Boolean },
    round: { type: Boolean },
    shadow: { type: Boolean },
    tile: { type: Boolean },
    route: { type: [String, Object] },
    forceLink: { type: Boolean },
    type: { type: String, default: "button" },
    disabled: { type: Boolean },
    loading: { type: Boolean },
    icon: { type: String, default: null },
    iconProps: { type: Object, default: () => ({}) },
    absolute: { type: Boolean },
    fixed: { type: Boolean },
    top: { type: Boolean },
    bottom: { type: Boolean },
    left: { type: Boolean },
    right: { type: Boolean },
    zIndex: { type: [Number, String] },
    width: { type: [Number, String] },
    height: { type: [Number, String] },
    xs: { type: Boolean },
    sm: { type: Boolean },
    md: { type: Boolean },
    lg: { type: Boolean },
    xl: { type: Boolean }
  },
  emits: [],
  computed: {
    hasRouter() {
      return "$router" in this;
    },
    resolvedRoute() {
      return this.hasRouter ? this.$router.resolve(this.route).href : this.route;
    },
    listeners() {
      return this.route && this.hasRouter && !this.forceLink && !this.externalLink ? {
        ...this.$attrs,
        click: (e) => {
          this.$attrs.click && this.$attrs.click(e), this.$router.push(this.route), e.stopPropagation(), e.preventDefault();
        }
      } : this.$attrs;
    },
    size() {
      return this.xs && "xs" || this.sm && "sm" || this.lg && "lg" || this.xl && "xl" || "md";
    },
    position() {
      return [
        this.top && "top" || this.bottom && "bottom" || "top",
        this.left && "left" || this.right && "right" || "right"
      ];
    },
    externalLink() {
      return /^(https?:)?\/\/|mailto:|tel:/.test(this.route);
    },
    classes() {
      return {
        "primary--bg": !this.bgColor && !this.color && !(this.outline || this.text),
        primary: !this.bgColor && !this.color && !this.dark && (this.outline || this.text),
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor,
        "w-button--dark": this.dark,
        "w-button--light": this.light,
        "w-button--outline": this.outline,
        "w-button--text": this.text,
        "w-button--round": this.round,
        "w-button--tile": this.tile,
        "w-button--shadow": this.shadow,
        "w-button--loading": this.loading,
        "w-button--icon": this.icon,
        [`size--${this.size}`]: !0,
        "w-button--absolute": this.absolute,
        "w-button--fixed": this.fixed,
        [`w-button--${this.position.join(" w-button--")}`]: this.absolute || this.fixed
      };
    },
    styles() {
      return {
        width: (isNaN(this.width) ? this.width : `${this.width}px`) || null,
        height: (isNaN(this.height) ? this.height : `${this.height}px`) || null,
        zIndex: this.zIndex || this.zIndex === 0 || null
      };
    }
  }
}, ft = /* @__PURE__ */ v(pt, [["render", ct]]), mt = ["innerHTML"];
function gt(e, t, l, a, o, i) {
  const n = $("button-partial");
  return l.tooltip ? (s(), g(V("w-tooltip"), ie(B({ key: 0 }, l.tooltipProps || {})), {
    activator: m(({ on: r }) => [
      I(n, B(i.buttonProps, N(r)), {
        default: m(() => [
          p(e.$slots, "default")
        ]),
        _: 2
      }, 1040)
    ]),
    default: m(() => [
      w("div", { innerHTML: l.tooltip }, null, 8, mt)
    ]),
    _: 3
  }, 16)) : (s(), g(n, ie(B({ key: 1 }, i.buttonProps)), {
    default: m(() => [
      p(e.$slots, "default")
    ]),
    _: 3
  }, 16));
}
const bt = {
  name: "w-button",
  inheritAttrs: !1,
  props: {
    color: { type: String },
    bgColor: { type: String },
    dark: { type: Boolean },
    outline: { type: Boolean },
    text: { type: Boolean },
    round: { type: Boolean },
    shadow: { type: Boolean },
    tile: { type: Boolean },
    tooltip: { type: String },
    tooltipProps: { type: Object, default: () => ({}) },
    route: { type: [String, Object] },
    forceLink: { type: Boolean },
    type: { type: String, default: "button" },
    disabled: { type: Boolean },
    loading: { type: Boolean },
    icon: { type: String, default: null },
    iconProps: { type: Object, default: () => ({}) },
    absolute: { type: Boolean },
    fixed: { type: Boolean },
    top: { type: Boolean },
    bottom: { type: Boolean },
    left: { type: Boolean },
    right: { type: Boolean },
    zIndex: { type: [Number, String] },
    width: { type: [Number, String] },
    height: { type: [Number, String] },
    xs: { type: Boolean },
    sm: { type: Boolean },
    md: { type: Boolean },
    lg: { type: Boolean },
    xl: { type: Boolean }
  },
  components: { ButtonPartial: ft },
  emits: [],
  computed: {
    buttonProps() {
      const { tooltip: e, tooltipProps: t, ...l } = this.$props;
      return { ...l, ...this.$attrs };
    }
  }
}, yt = /* @__PURE__ */ v(bt, [["render", gt]]), W = (e = {}) => (typeof e == "string" ? e = { [e]: !0 } : Array.isArray(e) && (e = { [e.join(" ")]: !0 }), e), wt = ["innerHTML"];
function vt(e, t, l, a, o, i) {
  const n = $("w-image");
  return s(), u("div", {
    class: f(["w-card", i.classes])
  }, [
    e.$slots.title ? (s(), u("div", {
      key: 0,
      class: f(["w-card__title", { "w-card__title--has-toolbar": e.$slots.title && i.titleHasToolbar, ...i.titleClasses }])
    }, [
      p(e.$slots, "title")
    ], 2)) : l.title ? (s(), u("div", {
      key: 1,
      class: f(["w-card__title", { "w-card__title--has-toolbar": e.$slots.title && i.titleHasToolbar, ...i.titleClasses }]),
      innerHTML: l.title
    }, null, 10, wt)) : c("", !0),
    l.image ? (s(), g(n, B({
      key: 2,
      class: "w-card__image",
      src: l.image
    }, i.imgProps), {
      default: m(() => [
        p(e.$slots, "image-content")
      ]),
      _: 3
    }, 16, ["src"])) : c("", !0),
    w("div", {
      class: f(["w-card__content", i.contentClasses])
    }, [
      p(e.$slots, "default")
    ], 2),
    e.$slots.actions ? (s(), u("div", {
      key: 3,
      class: f(["w-card__actions", { "w-card__actions--has-toolbar": i.actionsHasToolbar }])
    }, [
      p(e.$slots, "actions")
    ], 2)) : c("", !0)
  ], 2);
}
const kt = {
  name: "w-card",
  props: {
    color: { type: String },
    bgColor: { type: String },
    shadow: { type: Boolean },
    noBorder: { type: Boolean },
    tile: { type: Boolean },
    title: { type: String },
    image: { type: String },
    imageProps: { type: Object },
    titleClass: { type: [String, Object, Array] },
    contentClass: { type: [String, Object, Array] },
    dark: { type: Boolean },
    light: { type: Boolean }
  },
  emits: [],
  computed: {
    titleClasses() {
      return W(this.titleClass);
    },
    contentClasses() {
      return W(this.contentClass);
    },
    titleHasToolbar() {
      const { title: e } = this.$slots;
      return e && e().map((t) => t.type.name).join("").includes("w-toolbar");
    },
    actionsHasToolbar() {
      const { actions: e } = this.$slots;
      return e && e().map((t) => t.type.name).join("").includes("w-toolbar");
    },
    imgProps() {
      return {
        tag: "div",
        ratio: 1 / 2,
        ...this.imageProps
      };
    },
    classes() {
      return {
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor,
        "w-card--no-border": this.noBorder,
        "w-card--tile": this.tile,
        "w-card--shadow": this.shadow,
        "w-card--dark": this.dark,
        "w-card--light": this.light
      };
    }
  }
}, _t = /* @__PURE__ */ v(kt, [["render", vt]]), z = {
  inject: {
    formRegister: { default: null },
    formProps: { default: () => ({ disabled: !1, readonly: !1 }) }
  },
  props: {
    name: { type: String },
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    required: { type: Boolean },
    tabindex: { type: String },
    validators: { type: Array }
  },
  data: () => ({
    valid: null
  }),
  computed: {
    inputName() {
      return this.name || `${this.$options.name}--${this._.uid}`;
    },
    isDisabled() {
      return this.disabled || this.formProps.disabled;
    },
    isReadonly() {
      return this.readonly || this.formProps.readonly;
    },
    validationColor() {
      return this.formProps.validationColor;
    },
    labelClasses() {
      return {
        [this.labelColor]: this.labelColor && this.valid !== !1,
        [this.validationColor]: this.valid === !1
      };
    }
  },
  methods: {
    validate() {
      this.$refs.formEl.validate(this);
    }
  }
}, Ct = ["id", "name", "checked", "disabled", "required", "tabindex", "aria-checked"], Bt = ["for"], St = ["for", "innerHTML"], $t = /* @__PURE__ */ w("svg", { viewBox: "-0.5 0 12 10" }, [
  /* @__PURE__ */ w("polyline", { points: "1 5 4 8 10 2" })
], -1), Vt = [
  $t
], It = ["for"], Rt = ["for", "innerHTML"];
function Lt(e, t, l, a, o, i) {
  return s(), g(V(e.formRegister && !i.wCheckboxes ? "w-form-element" : "div"), B({ ref: "formEl" }, e.formRegister && { validators: e.validators, inputValue: o.isChecked, disabled: e.isDisabled }, {
    valid: e.valid,
    "onUpdate:valid": t[5] || (t[5] = (n) => e.valid = n),
    onReset: t[6] || (t[6] = (n) => {
      e.$emit("update:modelValue", o.isChecked = null), e.$emit("input", null);
    }),
    class: i.classes
  }), {
    default: m(() => [
      w("input", {
        ref: "input",
        id: `w-checkbox--${e._.uid}`,
        type: "checkbox",
        name: e.inputName,
        checked: o.isChecked || null,
        disabled: e.isDisabled || null,
        required: e.required || null,
        tabindex: e.tabindex || null,
        onFocus: t[0] || (t[0] = (n) => e.$emit("focus", n)),
        onBlur: t[1] || (t[1] = (n) => e.$emit("blur", n)),
        onChange: t[2] || (t[2] = (n) => i.onInput()),
        onKeypress: t[3] || (t[3] = M((...n) => i.onInput && i.onInput(...n), ["enter"])),
        "aria-checked": o.isChecked || "false",
        role: "checkbox"
      }, null, 40, Ct),
      i.hasLabel && l.labelOnLeft ? (s(), u(_, { key: 0 }, [
        e.$slots.default ? (s(), u("label", {
          key: 0,
          class: f(["w-checkbox__label w-form-el-shakable pr2", e.labelClasses]),
          for: `w-checkbox--${e._.uid}`
        }, [
          p(e.$slots, "default", {}, () => [
            C(k(l.label), 1)
          ])
        ], 10, Bt)) : l.label ? (s(), u("label", {
          key: 1,
          class: f(["w-checkbox__label w-form-el-shakable pr2", e.labelClasses]),
          for: `w-checkbox--${e._.uid}`,
          innerHTML: l.label
        }, null, 10, St)) : c("", !0)
      ], 64)) : c("", !0),
      w("div", {
        class: f(["w-checkbox__input", this.color]),
        onClick: t[4] || (t[4] = (n) => {
          e.$refs.input.focus(), e.$refs.input.click();
        })
      }, Vt, 2),
      i.hasLabel && !l.labelOnLeft ? (s(), u(_, { key: 1 }, [
        e.$slots.default ? (s(), u("label", {
          key: 0,
          class: f(["w-checkbox__label w-form-el-shakable pl2", e.labelClasses]),
          for: `w-checkbox--${e._.uid}`
        }, [
          p(e.$slots, "default", {}, () => [
            C(k(l.label), 1)
          ])
        ], 10, It)) : l.label ? (s(), u("label", {
          key: 1,
          class: f(["w-checkbox__label w-form-el-shakable pl2", e.labelClasses]),
          for: `w-checkbox--${e._.uid}`,
          innerHTML: l.label
        }, null, 10, Rt)) : c("", !0)
      ], 64)) : c("", !0)
    ]),
    _: 3
  }, 16, ["valid", "class"]);
}
const Tt = {
  name: "w-checkbox",
  mixins: [z],
  inject: {
    wCheckboxes: { default: null }
  },
  props: {
    modelValue: { default: !1 },
    returnValue: {},
    label: { type: String },
    labelOnLeft: { type: Boolean },
    color: { type: String, default: "primary" },
    labelColor: { type: String, default: "primary" },
    noRipple: { type: Boolean },
    indeterminate: { type: Boolean },
    round: { type: Boolean },
    dark: { type: Boolean },
    light: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "focus", "blur"],
  data() {
    return {
      isChecked: this.modelValue,
      ripple: {
        start: !1,
        end: !1,
        timeout: null
      }
    };
  },
  computed: {
    hasLabel() {
      return this.label || this.$slots.default;
    },
    classes() {
      return {
        [`w-checkbox w-checkbox--${this.isChecked ? "checked" : "unchecked"}`]: !0,
        "w-checkbox--disabled": this.isDisabled,
        "w-checkbox--indeterminate": this.indeterminate,
        "w-checkbox--ripple": this.ripple.start,
        "w-checkbox--rippled": this.ripple.end,
        "w-checkbox--round": this.round,
        "w-checkbox--dark": this.dark,
        "w-checkbox--light": this.light
      };
    }
  },
  methods: {
    onInput() {
      this.isChecked = !this.isChecked, this.$emit("update:modelValue", this.isChecked), this.$emit("input", this.isChecked), this.noRipple || (this.isChecked ? (this.ripple.start = !0, this.ripple.timeout = setTimeout(() => {
        this.ripple.start = !1, this.ripple.end = !0, setTimeout(() => this.ripple.end = !1, 100);
      }, 700)) : (this.ripple.start = !1, clearTimeout(this.ripple.timeout)));
    }
  },
  watch: {
    modelValue(e) {
      this.isChecked = e;
    }
  }
}, xt = /* @__PURE__ */ v(Tt, [["render", Lt]]), Pt = ["innerHTML"];
function Ot(e, t, l, a, o, i) {
  const n = $("w-checkbox");
  return s(), g(V(e.formRegister ? "w-form-element" : "div"), B({ ref: "formEl" }, e.formRegister && { validators: e.validators, inputValue: i.checkboxItems.some((r) => r._isChecked), disabled: e.isDisabled }, {
    valid: e.valid,
    "onUpdate:valid": t[1] || (t[1] = (r) => e.valid = r),
    onReset: i.reset,
    column: !l.inline,
    wrap: l.inline,
    class: i.classes
  }), {
    default: m(() => [
      (s(!0), u(_, null, T(i.checkboxItems, (r, d) => (s(), g(n, B({
        key: d,
        "model-value": r._isChecked,
        "onUpdate:modelValue": (h) => i.toggleCheck(r, h),
        onFocus: t[0] || (t[0] = (h) => e.$emit("focus", h)),
        name: `${e.inputName}[]`
      }, { label: r.label, color: r.color, labelOnLeft: l.labelOnLeft, labelColor: l.labelColor, round: l.round }, {
        disabled: e.isDisabled || null,
        readonly: e.isReadonly || null,
        class: { mt1: !l.inline && d }
      }), {
        default: m(() => [
          e.$slots[`item.${d + 1}`] || e.$slots.item ? p(e.$slots, e.$slots[`item.${d + 1}`] ? `item.${d + 1}` : "item", {
            key: 0,
            item: i.getOriginalItem(r),
            checked: !!r._isChecked,
            index: d + 1,
            innerHTML: r.label
          }) : r.label ? (s(), u("div", {
            key: 1,
            innerHTML: r.label
          }, null, 8, Pt)) : c("", !0)
        ]),
        _: 2
      }, 1040, ["model-value", "onUpdate:modelValue", "name", "disabled", "readonly", "class"]))), 128))
    ]),
    _: 3
  }, 16, ["valid", "onReset", "column", "wrap", "class"]);
}
const zt = {
  name: "w-checkboxes",
  mixins: [z],
  props: {
    items: { type: Array, required: !0 },
    modelValue: { type: Array },
    labelOnLeft: { type: Boolean },
    itemLabelKey: { type: String, default: "label" },
    itemValueKey: { type: String, default: "value" },
    itemColorKey: { type: String, default: "color" },
    inline: { type: Boolean },
    round: { type: Boolean },
    color: { type: String, default: "primary" },
    labelColor: { type: String, default: "primary" }
  },
  emits: ["input", "update:modelValue", "focus"],
  provide() {
    return { wCheckboxes: !0 };
  },
  computed: {
    checkboxItems() {
      return (this.items || []).map((e, t) => {
        const l = e[this.itemValueKey] === void 0 ? e[this.itemLabelKey] || t : e[this.itemValueKey];
        return G({
          ...e,
          label: e[this.itemLabelKey],
          _index: t,
          value: l,
          color: e[this.itemColorKey] || this.color,
          _isChecked: this.modelValue && this.modelValue.includes(l)
        });
      });
    },
    classes() {
      return [
        "w-checkboxes",
        `w-checkboxes--${this.inline ? "inline" : "column"}`
      ];
    }
  },
  methods: {
    reset() {
      this.checkboxItems.forEach((e) => e._isChecked = null), this.$emit("update:modelValue", []), this.$emit("input", []);
    },
    toggleCheck(e, t) {
      e._isChecked = t;
      const l = this.checkboxItems.filter((a) => a._isChecked).map((a) => a.value);
      this.$emit("update:modelValue", l), this.$emit("input", l);
    },
    getOriginalItem(e) {
      return this.items[e._index];
    }
  }
}, Et = /* @__PURE__ */ v(zt, [["render", Ot]]);
function Mt(e, t, l, a, o, i) {
  const n = $("w-button"), r = $("w-flex"), d = $("w-menu"), h = fe("focus");
  return s(), g(d, B({
    modelValue: e.showPopup,
    "onUpdate:modelValue": t[2] || (t[2] = (y) => e.showPopup = y)
  }, i.wMenuProps), {
    activator: m(({ on: y }) => [
      I(n, B({ class: "w-confirm" }, { ...e.$attrs, ...i.buttonProps, ...l.disablePrompt ? {} : y }), {
        default: m(() => [
          p(e.$slots, "default")
        ]),
        _: 2
      }, 1040)
    ]),
    default: m(() => [
      I(r, {
        column: !l.inline,
        "align-center": ""
      }, {
        default: m(() => [
          w("div", null, [
            p(e.$slots, "question", {}, () => [
              C(k(l.question), 1)
            ])
          ]),
          w("div", {
            class: f(["w-flex justify-end", l.inline ? "ml2" : "mt2"])
          }, [
            l.cancel !== !1 ? (s(), g(n, B({
              key: 0,
              class: "mr2"
            }, i.cancelButtonProps, {
              "bg-color": (i.cancelButton || {}).bgColor || "error",
              onKeyup: t[0] || (t[0] = M((y) => !l.persistent && i.onCancel(), ["escape"])),
              onClick: i.onCancel
            }), {
              default: m(() => [
                p(e.$slots, "cancel", {}, () => [
                  C(k(i.cancelButton.label), 1)
                ])
              ]),
              _: 3
            }, 16, ["bg-color", "onClick"])) : c("", !0),
            D((s(), g(n, B(i.confirmButtonProps, {
              "bg-color": (i.confirmButton || {}).bgColor || "success",
              onKeyup: t[1] || (t[1] = M((y) => !l.persistent && i.onCancel(), ["escape"])),
              onClick: i.onConfirm
            }), {
              default: m(() => [
                p(e.$slots, "confirm", {}, () => [
                  C(k(i.confirmButton.label), 1)
                ])
              ]),
              _: 3
            }, 16, ["bg-color", "onClick"])), [
              [h]
            ])
          ], 2)
        ]),
        _: 3
      }, 8, ["column"])
    ]),
    _: 3
  }, 16, ["modelValue"]);
}
const Nt = {
  name: "w-confirm",
  inheritAttrs: !1,
  props: {
    bgColor: { type: String },
    color: { type: String },
    icon: { type: String },
    disablePrompt: { type: Boolean },
    mainButton: { type: Object },
    question: { type: String, default: "Are you sure?" },
    cancel: { type: [Boolean, Object, String], default: void 0 },
    confirm: { type: [Object, String] },
    inline: { type: Boolean },
    menu: { type: Object, default: () => ({}) },
    tooltip: { type: [Boolean, Object, String] },
    noArrow: { type: Boolean },
    top: { type: Boolean },
    bottom: { type: Boolean },
    left: { type: Boolean },
    right: { type: Boolean },
    alignTop: { type: Boolean },
    alignBottom: { type: Boolean },
    alignLeft: { type: Boolean },
    alignRight: { type: Boolean },
    persistent: { type: Boolean },
    transition: { type: String },
    dark: { type: Boolean },
    light: { type: Boolean }
  },
  emits: ["cancel", "confirm"],
  data: () => ({
    showPopup: !1,
    props: []
  }),
  computed: {
    cancelButton() {
      let e = { label: typeof this.cancel == "string" ? this.cancel : "Cancel" };
      return typeof this.cancel == "object" && (e = Object.assign({}, e, this.cancel)), e;
    },
    cancelButtonProps() {
      const { label: e, ...t } = this.cancelButton;
      return t;
    },
    confirmButton() {
      let e = { label: typeof this.confirm == "string" ? this.confirm : "Confirm" };
      return typeof this.confirm == "object" && (e = Object.assign({}, e, this.confirm)), e;
    },
    confirmButtonProps() {
      const { label: e, ...t } = this.confirmButton;
      return t;
    },
    wMenuProps() {
      return {
        top: this.top,
        bottom: this.bottom,
        left: this.left,
        right: this.right,
        arrow: !this.noArrow,
        alignTop: this.alignTop,
        alignBottom: this.alignBottom,
        alignLeft: this.alignLeft,
        alignRight: this.alignRight,
        persistent: this.persistent,
        transition: this.transition,
        ...this.menu
      };
    },
    tooltipObject() {
      let e = { label: typeof this.tooltip == "string" ? this.tooltip : "" };
      return typeof this.tooltip == "object" && (e = Object.assign({}, e, this.tooltip)), e;
    },
    buttonProps() {
      const { label: e, ...t } = this.tooltipObject;
      return {
        bgColor: this.bgColor,
        color: this.color,
        icon: this.icon,
        dark: this.dark,
        light: this.light,
        tooltip: e,
        tooltipProps: t,
        ...this.mainButton
      };
    }
  },
  methods: {
    onCancel() {
      this.$emit("cancel"), this.showPopup = !1;
    },
    onConfirm() {
      this.$emit("confirm"), this.showPopup = !1;
    }
  }
}, Wt = /* @__PURE__ */ v(Nt, [["render", Mt]]);
function At(e, t, l, a, o, i) {
  return s(), u("div", {
    class: f(["w-date-picker", i.classes]),
    style: L(i.styles)
  }, [
    p(e.$slots, "default")
  ], 6);
}
const Kt = {
  name: "w-date-picker",
  props: {
    dark: { type: Boolean },
    light: { type: Boolean }
  },
  emits: [],
  computed: {
    classes() {
      return {
        "w-date-picker--dark": this.dark,
        "w-date-picker--light": this.light
      };
    },
    styles() {
      return !1;
    }
  }
}, Dt = /* @__PURE__ */ v(Kt, [["render", At]]);
function Ft(e, t, l, a, o, i) {
  const n = $("w-card"), r = $("w-overlay");
  return s(), g(r, {
    class: f(["w-dialog", i.classes]),
    "model-value": o.showWrapper,
    persistent: l.persistent,
    "persistent-no-animation": l.persistentNoAnimation,
    onClick: i.onOutsideClick,
    onClose: i.onClose,
    "bg-color": l.overlayColor,
    opacity: l.overlayOpacity
  }, {
    default: m(() => [
      I(x, {
        name: l.transition,
        appear: "",
        onAfterLeave: i.onBeforeClose
      }, {
        default: m(() => [
          D(I(n, {
            class: f(["w-dialog__content", l.dialogClass]),
            ref: "dialog",
            "no-border": "",
            color: l.color,
            "bg-color": l.bgColor,
            "title-class": l.titleClass,
            "content-class": l.contentClass,
            title: l.title || void 0,
            style: L(i.contentStyles)
          }, Z({
            default: m(() => [
              p(e.$slots, "default")
            ]),
            _: 2
          }, [
            e.$slots.title ? {
              name: "title",
              fn: m(() => [
                p(e.$slots, "title")
              ]),
              key: "0"
            } : void 0,
            e.$slots.actions ? {
              name: "actions",
              fn: m(() => [
                p(e.$slots, "actions")
              ]),
              key: "1"
            } : void 0
          ]), 1032, ["color", "bg-color", "class", "title-class", "content-class", "title", "style"]), [
            [me, o.showContent]
          ])
        ]),
        _: 3
      }, 8, ["name", "onAfterLeave"])
    ]),
    _: 3
  }, 8, ["model-value", "persistent", "persistent-no-animation", "onClick", "onClose", "bg-color", "opacity", "class"]);
}
const Ht = {
  name: "w-dialog",
  props: {
    modelValue: { default: !0 },
    width: { type: [Number, String], default: 0 },
    fullscreen: { type: Boolean },
    persistent: { type: Boolean },
    persistentNoAnimation: { type: Boolean },
    tile: { type: Boolean },
    title: { type: String },
    transition: { type: String, default: "fade" },
    titleClass: { type: String },
    contentClass: { type: String },
    dialogClass: { type: String },
    overlayColor: { type: String },
    color: { type: String },
    bgColor: { type: String },
    overlayOpacity: { type: [Number, String, Boolean] },
    dark: { type: Boolean },
    light: { type: Boolean }
  },
  provide() {
    return {
      detachableDefaultRoot: () => this.$refs.dialog.$el || null
    };
  },
  emits: ["input", "update:modelValue", "before-close", "close"],
  data() {
    return {
      showWrapper: this.modelValue,
      showContent: this.modelValue
    };
  },
  computed: {
    maxWidth() {
      let e = this.width;
      return e && parseInt(e) == e && (e += "px"), e;
    },
    classes() {
      return {
        "w-dialog--fullscreen": this.fullscreen,
        "w-dialog--dark": this.dark,
        "w-dialog--light": this.light
      };
    },
    contentStyles() {
      return {
        maxWidth: !this.fullscreen && this.maxWidth ? this.maxWidth : null
      };
    }
  },
  methods: {
    onOutsideClick() {
      this.persistent || (this.showContent = !1, this.transition === "fade" && this.onBeforeClose());
    },
    onBeforeClose() {
      this.showWrapper = !1, this.$emit("before-close");
    },
    onClose() {
      this.$emit("update:modelValue", !1), this.$emit("input", !1), this.$emit("close");
    }
  },
  watch: {
    modelValue(e) {
      this.showWrapper = e, this.showContent = e;
    }
  }
}, jt = /* @__PURE__ */ v(Ht, [["render", Ft]]), Ut = ["role", "aria-orientation"];
function qt(e, t, l, a, o, i) {
  return s(), u("div", {
    class: f(["w-divider", i.classes]),
    role: e.$slots.default ? null : "presentation",
    "aria-orientation": l.vertical ? "vertical" : "horizontal"
  }, [
    p(e.$slots, "default")
  ], 10, Ut);
}
const Gt = {
  name: "w-divider",
  props: {
    vertical: { type: Boolean },
    color: { type: String },
    dark: { type: Boolean },
    light: { type: Boolean }
  },
  emits: [],
  computed: {
    classes() {
      return {
        [`w-divider--has-color ${this.color}`]: this.color,
        [`w-divider--${this.vertical ? "vertical" : "horizontal"}`]: !0,
        "w-divider--has-content": this.$slots.default,
        "w-divider--dark": this.dark,
        "w-divider--light": this.light
      };
    }
  }
}, Xt = /* @__PURE__ */ v(Gt, [["render", qt]]), Yt = { class: "w-drawer-wrap__pushable" };
function Jt(e, t, l, a, o, i) {
  const n = $("w-overlay");
  return o.showWrapper || l.pushContent ? (s(), u("div", {
    key: 0,
    class: f(["w-drawer-wrap", i.wrapperClasses])
  }, [
    l.pushContent ? (s(), u("div", {
      key: 0,
      class: "w-drawer-wrap__track",
      style: L(i.trackStyles)
    }, [
      w("div", Yt, [
        l.noOverlay ? c("", !0) : (s(), g(n, {
          key: 0,
          modelValue: o.showDrawer,
          "onUpdate:modelValue": t[0] || (t[0] = (r) => o.showDrawer = r),
          onClick: i.onOutsideClick,
          persistent: l.persistent,
          "persistent-no-animation": "",
          "bg-color": l.overlayColor || "transparent",
          opacity: l.overlayOpacity
        }, null, 8, ["modelValue", "onClick", "persistent", "bg-color", "opacity"])),
        p(e.$slots, "pushable")
      ]),
      I(x, {
        name: "fade",
        onBeforeLeave: i.onBeforeClose,
        onAfterLeave: i.onClose
      }, {
        default: m(() => [
          o.showDrawer ? (s(), g(V(l.tag || "aside"), {
            key: 0,
            class: f(["w-drawer", i.drawerClasses]),
            ref: "drawer",
            style: L(i.styles)
          }, {
            default: m(() => [
              p(e.$slots, "default")
            ]),
            _: 3
          }, 8, ["class", "style"])) : c("", !0)
        ]),
        _: 3
      }, 8, ["onBeforeLeave", "onAfterLeave"])
    ], 4)) : (s(), u(_, { key: 1 }, [
      l.noOverlay ? c("", !0) : (s(), g(n, {
        key: 0,
        modelValue: o.showDrawer,
        "onUpdate:modelValue": t[1] || (t[1] = (r) => o.showDrawer = r),
        onClick: i.onOutsideClick,
        persistent: l.persistent,
        "persistent-no-animation": "",
        "bg-color": l.overlayColor,
        opacity: l.overlayOpacity
      }, null, 8, ["modelValue", "onClick", "persistent", "bg-color", "opacity"])),
      I(x, {
        name: i.transitionName,
        appear: "",
        onBeforeLeave: i.onBeforeClose,
        onAfterLeave: i.onClose
      }, {
        default: m(() => [
          o.showDrawer ? (s(), g(V(l.tag || "aside"), {
            key: 0,
            class: f(["w-drawer", i.drawerClasses]),
            ref: "drawer",
            style: L(i.styles)
          }, {
            default: m(() => [
              p(e.$slots, "default")
            ]),
            _: 3
          }, 8, ["class", "style"])) : c("", !0)
        ]),
        _: 3
      }, 8, ["name", "onBeforeLeave", "onAfterLeave"])
    ], 64))
  ], 2)) : c("", !0);
}
const Qt = { left: "right", right: "left", top: "down", bottom: "up" }, Zt = {
  name: "w-drawer",
  props: {
    modelValue: { default: !0 },
    left: { type: Boolean },
    right: { type: Boolean },
    top: { type: Boolean },
    bottom: { type: Boolean },
    persistent: { type: Boolean },
    persistentNoAnimation: { type: Boolean },
    fitContent: { type: Boolean },
    width: { type: [Number, String, Boolean] },
    height: { type: [Number, String, Boolean] },
    zIndex: { type: [Number, String, Boolean] },
    color: { type: String },
    bgColor: { type: String },
    noOverlay: { type: Boolean },
    pushContent: { type: Boolean },
    absolute: { type: Boolean },
    overlayColor: { type: String },
    overlayOpacity: { type: [Number, String, Boolean] },
    drawerClass: { type: String },
    tag: { type: String, default: "aside" },
    dark: { type: Boolean },
    light: { type: Boolean }
  },
  provide() {
    return {
      detachableDefaultRoot: () => this.$refs.drawer || null
    };
  },
  emits: ["input", "update:modelValue", "before-close", "close"],
  data() {
    return {
      showWrapper: this.modelValue,
      showDrawer: this.modelValue,
      persistentAnimate: !1
    };
  },
  computed: {
    size() {
      let e = this.width || this.height;
      return e && parseInt(e) == e && (e += "px"), e || !1;
    },
    sizeProperty() {
      return ["left", "right"].includes(this.position) && "width" || "height";
    },
    position() {
      return this.left && "left" || this.right && "right" || this.top && "top" || this.bottom && "bottom" || "right";
    },
    wrapperClasses() {
      return {
        "w-drawer-wrap--fixed": !this.absolute && !this.pushContent,
        "w-drawer-wrap--absolute": this.absolute,
        "w-drawer-wrap--push-content": this.pushContent
      };
    },
    drawerClasses() {
      return {
        [this.drawerClass]: !0,
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor,
        "w-drawer--open": !!this.showDrawer,
        [`w-drawer--${this.position}`]: !0,
        "w-drawer--fit-content": this.fitContent,
        "w-drawer--persistent": this.persistent,
        "w-drawer--persistent-animate": this.persistent && this.persistentAnimate,
        "w-drawer--dark": this.dark,
        "w-drawer--light": this.light
      };
    },
    trackStyles() {
      return this.pushContent && this.showDrawer && {
        transform: `translateX(${this.position === "left" ? "" : "-"}${this.size || "200px"})`
      };
    },
    styles() {
      return {
        [`max-${this.sizeProperty}`]: this.size || null,
        zIndex: this.zIndex || this.zIndex === 0 || null
      };
    },
    unmountDrawer() {
      return !this.showWrapper;
    },
    transitionName() {
      return `slide-${Qt[this.position]}`;
    }
  },
  methods: {
    onBeforeClose() {
      this.$emit("before-close");
    },
    onClose() {
      this.showWrapper = !1, this.$emit("update:modelValue", !1), this.$emit("input", !1), this.$emit("close");
    },
    onOutsideClick() {
      this.persistent ? this.persistentNoAnimation || (this.persistentAnimate = !0, setTimeout(() => this.persistentAnimate = !1, 200)) : this.showDrawer = !1;
    }
  },
  watch: {
    modelValue(e) {
      e && (this.showWrapper = !0), this.showDrawer = e;
    }
  }
}, el = /* @__PURE__ */ v(Zt, [["render", Jt]]);
function tl(e, t, l, a, o, i) {
  return s(), g(V(l.tag), {
    class: f(["w-flex", i.classes])
  }, {
    default: m(() => [
      p(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
const ll = {
  name: "w-flex",
  props: {
    tag: { type: String, default: "div" },
    column: { type: Boolean },
    grow: { type: Boolean },
    noGrow: { type: Boolean },
    shrink: { type: Boolean },
    noShrink: { type: Boolean },
    fillHeight: { type: Boolean },
    wrap: { type: Boolean },
    alignStart: { type: Boolean },
    alignCenter: { type: Boolean },
    alignEnd: { type: Boolean },
    justifyStart: { type: Boolean },
    justifyCenter: { type: Boolean },
    justifyEnd: { type: Boolean },
    justifySpaceBetween: { type: Boolean },
    justifySpaceAround: { type: Boolean },
    justifySpaceEvenly: { type: Boolean },
    basisZero: { type: Boolean },
    gap: { type: [Number, String], default: 0 }
  },
  computed: {
    classes() {
      return {
        column: this.column,
        grow: this.grow,
        "no-grow": this.noGrow,
        shrink: this.shrink,
        "no-shrink": this.noShrink,
        "fill-height": this.fillHeight,
        wrap: this.wrap,
        "align-start": this.alignStart,
        "align-center": this.alignCenter,
        "align-end": this.alignEnd,
        "justify-start": this.justifyStart,
        "justify-center": this.justifyCenter,
        "justify-end": this.justifyEnd,
        "justify-space-between": this.justifySpaceBetween,
        "justify-space-around": this.justifySpaceAround,
        "justify-space-evenly": this.justifySpaceEvenly,
        "basis-zero": this.basisZero,
        [`gap${this.gap}`]: ~~this.gap
      };
    }
  }
}, il = /* @__PURE__ */ v(ll, [["render", tl]]);
function sl(e, t, l, a, o, i) {
  return s(), u("form", {
    class: f(["w-form", i.classes]),
    onSubmit: t[0] || (t[0] = (...n) => i.onSubmit && i.onSubmit(...n)),
    onReset: t[1] || (t[1] = (...n) => i.reset && i.reset(...n)),
    novalidate: ""
  }, [
    p(e.$slots, "default")
  ], 34);
}
const al = async (e, t) => {
  for (const l of e)
    if (await t(l))
      return !0;
  return !1;
}, ol = {
  name: "w-form",
  props: {
    modelValue: {},
    allowSubmit: { type: Boolean },
    noKeyupValidation: { type: Boolean },
    noBlurValidation: { type: Boolean },
    errorPlaceholders: { type: Boolean },
    validationColor: { type: String, default: "error" },
    disabled: { type: Boolean },
    readonly: { type: Boolean }
  },
  provide() {
    return {
      formRegister: this.register,
      formUnregister: this.unregister,
      validateElement: this.validateElement,
      formProps: this.$props
    };
  },
  emits: [
    "submit",
    "before-validate",
    "validate",
    "success",
    "error",
    "reset",
    "input",
    "update:modelValue",
    "update:errorsCount"
  ],
  data: () => ({
    formElements: [],
    status: null,
    errorsCount: 0
  }),
  computed: {
    classes() {
      return {
        "w-form--pristine": this.status === null,
        "w-form--error": this.status === !1,
        "w-form--success": this.status === !0,
        "w-form--error-placeholders": this.errorPlaceholders
      };
    }
  },
  methods: {
    register(e) {
      this.formElements.push(e);
    },
    unregister(e) {
      this.formElements = this.formElements.filter((t) => t._.uid !== e._.uid);
    },
    async validate(e) {
      this.$emit("before-validate", { e, errorsCount: this.errorsCount });
      let t = 0;
      return await (async () => {
        var l;
        for (const a of this.formElements)
          !((l = a.validators) != null && l.length) || a.disabled || a.readonly || (await this.checkElementValidators(a), t += ~~!a.Validation.isValid, a.$emit("update:valid", a.Validation.isValid));
      })(), this.updateErrorsCount(t), this.status = !t, this.$emit("validate", { e, errorsCount: t }), this.$emit(this.status ? "success" : "error", { e, errorsCount: t }), this.status;
    },
    async validateElement(e) {
      return await this.checkElementValidators(e), this.updateErrorsCount(), e.Validation.isValid;
    },
    async checkElementValidators(e) {
      let t = !1, l = "";
      await al(e.validators, async (a) => {
        const o = await (typeof a == "function" && a(e.inputValue));
        return t = typeof o != "string", l = t ? "" : o, !t;
      }), e.hasJustReset = !1, e.Validation.isValid = t, e.Validation.message = l;
    },
    reset(e) {
      this.status = null, this.formElements.forEach((t) => t.reset()), this.updateErrorsCount(0, !0), this.$emit("reset", e);
    },
    updateErrorsCount(e = null, t = !1) {
      this.errorsCount = e !== null ? e : this.formElements.reduce((l, a) => l + ~~(a.Validation.isValid === !1), 0), this.status = t ? null : !this.errorsCount, this.$emit("update:modelValue", this.status), this.$emit("input", this.status), this.$emit("update:errorsCount", this.errorsCount);
    },
    onSubmit(e) {
      this.validate(e), this.$emit("submit", e), (!this.allowSubmit || !this.status) && e.preventDefault();
    }
  },
  created() {
    this.status = this.modelValue || null;
  },
  watch: {
    modelValue(e) {
      (this.status === !1 && e || e === null && this.status !== null) && this.reset(), this.status = e;
    }
  }
}, nl = /* @__PURE__ */ v(ol, [["render", sl]]);
function rl(e, t, l, a, o, i) {
  const n = $("w-transition-expand");
  return s(), u("div", {
    class: f(i.classes)
  }, [
    w("div", {
      class: f(["w-flex grow", [l.column ? "column" : "align-center", l.wrap ? "wrap" : ""]])
    }, [
      p(e.$slots, "default")
    ], 2),
    I(n, { y: "" }, {
      default: m(() => [
        e.Validation.message ? (s(), u("div", {
          key: 0,
          class: f(["w-form-el__error", i.formProps.validationColor])
        }, [
          p(e.$slots, "error-message", {
            message: e.Validation.message
          }, () => [
            C(k(e.Validation.message), 1)
          ])
        ], 2)) : c("", !0)
      ]),
      _: 3
    })
  ], 2);
}
const dl = {
  name: "w-form-element",
  props: {
    valid: { required: !0 },
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    inputValue: { required: !0 },
    validators: { type: Array },
    isFocused: { default: !1 },
    column: { default: !1 },
    wrap: { default: !1 }
  },
  inject: {
    formRegister: { default: null },
    formUnregister: { default: null },
    validateElement: { default: null },
    formProps: {
      default: () => ({
        noKeyupValidation: !1,
        noBlurValidation: !1,
        validationColor: "error",
        disabled: !1,
        readonly: !1
      })
    }
  },
  emits: ["reset", "update:valid"],
  data: () => ({
    Validation: {
      isValid: null,
      message: ""
    },
    hasJustReset: !1
  }),
  computed: {
    classes() {
      return [
        "w-form-el",
        ["w-form-el--error error", "w-form-el--success", "w-form-el--pristine"][this.Validation.isValid === null ? 2 : ~~this.Validation.isValid]
      ];
    }
  },
  methods: {
    reset() {
      this.$emit("reset"), this.$emit("update:valid", null), this.Validation.message = "", this.Validation.isValid = null, this.hasJustReset = !0;
    },
    async validate() {
      this.$emit("update:valid", await this.validateElement(this));
    }
  },
  watch: {
    async inputValue() {
      if (this.hasJustReset)
        return this.hasJustReset = !1;
      !this.formProps.noKeyupValidation && this.validators && this.$emit("update:valid", await this.validateElement(this));
    },
    async isFocused(e) {
      e ? this.hasJustReset = !1 : !this.formProps.noBlurValidation && this.validators && !this.readonly && this.$emit("update:valid", await this.validateElement(this));
    }
  },
  created() {
    this.formRegister && this.formRegister(this);
  },
  beforeUnmount() {
    this.formUnregister && this.formUnregister(this);
  }
}, ul = /* @__PURE__ */ v(dl, [["render", rl]]);
function hl(e, t, l, a, o, i) {
  return s(), g(V(l.tag), {
    class: f(["w-grid", i.classes])
  }, {
    default: m(() => [
      p(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
const cl = {
  name: "w-grid",
  props: {
    tag: { type: String, default: "div" },
    columns: { type: [Number, Object, String] },
    gap: { type: [Number, Object, String], default: 0 }
  },
  computed: {
    breakpointsColumns() {
      let e = { xs: 0, sm: 0, md: 0, lg: 0, xl: 0 };
      switch (typeof this.columns) {
        case "object":
          e = Object.assign(e, this.columns);
          break;
        case "number":
        case "string":
          e = Object.keys(e).reduce((t, l) => t[l] = ~~this.columns, {});
          break;
      }
      return e;
    },
    breakpointsGap() {
      let e = { xs: 0, sm: 0, md: 0, lg: 0, xl: 0 };
      switch (typeof this.gap) {
        case "object":
          e = Object.assign(e, this.gap);
          break;
        case "number":
        case "string":
          e = Object.keys(e).reduce((t, l) => t[l] = ~~this.gap, {});
          break;
      }
      return e;
    },
    classes() {
      let e = null;
      typeof this.columns == "object" && (e = Object.entries(this.breakpointsColumns).reduce((l, [a, o]) => (l[`${a}-columns${o}`] = !0, l), {}));
      let t = null;
      return typeof this.gap == "object" && (t = Object.entries(this.breakpointsGap).reduce((l, [a, o]) => (l[`${a}-gap${o}`] = !0, l), {})), {
        ...e || { [`columns${this.columns}`]: this.columns },
        ...t || { [`gap${this.gap}`]: this.gap }
      };
    }
  }
}, pl = /* @__PURE__ */ v(cl, [["render", hl]]);
function fl(e, t, l, a, o, i) {
  return s(), g(V(l.tag || "i"), B({ class: "w-icon" }, N(e.$attrs), {
    class: i.classes,
    role: "icon",
    "aria-hidden": "true",
    style: i.readIcon() && i.styles
  }), {
    default: m(() => [
      i.hasLigature ? (s(), u(_, { key: 0 }, [
        C(k(e.icon), 1)
      ], 64)) : c("", !0)
    ]),
    _: 1
  }, 16, ["class", "style"]);
}
const ml = {
  name: "w-icon",
  props: {
    tag: { type: String, default: "i" },
    color: { type: String },
    bgColor: { type: String },
    xs: { type: Boolean },
    sm: { type: Boolean },
    md: { type: Boolean },
    lg: { type: Boolean },
    xl: { type: Boolean },
    spin: { type: Boolean },
    spinA: { type: Boolean },
    rotate135a: { type: Boolean },
    rotate90a: { type: Boolean },
    rotate45a: { type: Boolean },
    rotate45: { type: Boolean },
    rotate90: { type: Boolean },
    rotate135: { type: Boolean },
    rotate180: { type: Boolean },
    flipX: { type: Boolean },
    flipY: { type: Boolean },
    size: { type: [Number, String] }
  },
  emits: [],
  data: () => ({
    icon: "",
    fontName: ""
  }),
  computed: {
    hasLigature() {
      return this.$waveui.config.iconsLigature === this.fontName;
    },
    forcedSize() {
      return this.size && (isNaN(this.size) ? this.size : `${this.size}px`);
    },
    presetSize() {
      return this.xs && "xs" || this.sm && "sm" || this.md && "md" || this.lg && "lg" || this.xl && "xl" || null;
    },
    classes() {
      return {
        [this.fontName]: !0,
        [!this.hasLigature && this.icon]: !this.hasLigature && this.icon,
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor,
        [`size--${this.presetSize}`]: this.presetSize && !this.forcedSize,
        "w-icon--spin": this.spin,
        "w-icon--spin-a": this.spinA,
        "w-icon--rotate45": this.rotate45,
        "w-icon--rotate90": this.rotate90,
        "w-icon--rotate135": this.rotate135,
        "w-icon--rotate180": this.rotate180,
        "w-icon--rotate-45": this.rotate45a,
        "w-icon--rotate-90": this.rotate90a,
        "w-icon--rotate-135": this.rotate135a,
        "w-icon--flip-x": this.flipX,
        "w-icon--flip-y": this.flipY
      };
    },
    styles() {
      return this.forcedSize && `font-size: ${this.forcedSize}`;
    }
  },
  methods: {
    readIcon() {
      const { default: e } = this.$slots, [t = "", l = ""] = typeof e == "function" && e()[0].children.trim().split(" ") || [];
      return this.fontName = t, this.icon = l, !0;
    }
  }
}, gl = /* @__PURE__ */ v(ml, [["render", fl]]), J = (e) => console.warn(`Wave UI: ${e}`), le = (e) => console.error(`Wave UI: ${e}`), bl = {
  key: 0,
  class: "w-image__loader"
};
function yl(e, t, l, a, o, i) {
  const n = $("w-progress");
  return s(), g(V(i.wrapperTag), {
    class: f(["w-image-wrap", i.wrapperClasses]),
    style: L(i.wrapperStyles)
  }, {
    default: m(() => [
      I(x, {
        name: l.transition,
        appear: ""
      }, {
        default: m(() => [
          o.loaded ? (s(), g(V(l.tag), {
            key: 0,
            class: f(["w-image", i.imageClasses]),
            style: L(i.imageStyles),
            src: l.tag === "img" ? o.imgSrc : null
          }, null, 8, ["class", "style", "src"])) : c("", !0)
        ]),
        _: 1
      }, 8, ["name"]),
      !l.noSpinner && o.loading ? (s(), u("div", bl, [
        e.$slots.loading ? p(e.$slots, "loading", { key: 0 }) : (s(), g(n, B({
          key: 1,
          circle: "",
          indeterminate: ""
        }, l.spinnerColor ? { color: l.spinnerColor } : {}), null, 16))
      ])) : c("", !0),
      e.$slots.default ? (s(), g(V(i.wrapperTag), {
        key: 1,
        class: f(["w-image__content", l.contentClass])
      }, {
        default: m(() => [
          p(e.$slots, "default")
        ]),
        _: 3
      }, 8, ["class"])) : c("", !0)
    ]),
    _: 3
  }, 8, ["class", "style"]);
}
const wl = {
  name: "w-image",
  props: {
    tag: { type: String, default: "span" },
    src: { type: String },
    width: { type: [Number, String] },
    height: { type: [Number, String] },
    ratio: { type: [Number, String] },
    lazy: { type: Boolean },
    absolute: { type: Boolean },
    fixed: { type: Boolean },
    contain: { type: Boolean },
    noSpinner: { type: Boolean },
    spinnerColor: { type: String },
    fallback: { type: String },
    transition: { type: String, default: "fade" },
    contentClass: { type: [String, Array, Object] }
  },
  emits: ["loading", "loaded", "error"],
  data() {
    return {
      loading: !1,
      loaded: !1,
      imgSrc: "",
      imgWidth: this.width || 0,
      imgHeight: this.height || 0,
      imgComputedRatio: 0
    };
  },
  computed: {
    imgGivenRatio() {
      return parseFloat(this.ratio);
    },
    wrapperTag() {
      return ["span", "div"].includes(this.tag) ? this.tag : "span";
    },
    wrapperClasses() {
      return {
        "w-image-wrap--absolute": this.absolute,
        "w-image-wrap--fixed": this.fixed,
        "w-image-wrap--has-ratio": this.imgGivenRatio
      };
    },
    wrapperStyles() {
      return {
        width: this.imgGivenRatio ? null : (isNaN(this.imgWidth) ? this.imgWidth : `${this.imgWidth}px`) || null,
        height: this.imgGivenRatio || this.tag === "img" ? null : (isNaN(this.imgHeight) ? this.imgHeight : `${this.imgHeight}px`) || null,
        "padding-bottom": this.imgGivenRatio && `${this.imgGivenRatio * 100}%`
      };
    },
    imageClasses() {
      return {
        "w-image--loading": this.loading,
        "w-image--loaded": this.loaded,
        "w-image--contain": this.contain
      };
    },
    imageStyles() {
      return {
        "background-image": this.tag !== "img" && this.loaded ? `url('${this.imgSrc}')` : null
      };
    }
  },
  methods: {
    loadImage(e = !1) {
      if (!this.loading)
        return this.loading = !0, this.loaded = !1, this.$emit("loading", e ? this.fallback : this.src), new Promise((t) => {
          const l = new Image();
          l.onload = (a) => (!this.width && !this.height && !this.imgGivenRatio && (this.imgWidth = a.target.width, this.imgHeight = a.target.height), this.imgComputedRatio = a.target.height / a.target.width, this.loading = !1, this.loaded = !0, this.imgSrc = e ? this.fallback : this.src, this.$emit("loaded", this.imgSrc), t(l)), l.onerror = (a) => {
            this.$emit("error", a), this.fallback && !e ? (this.loading = !1, this.loadImage(!0)) : (this.loading = !1, this.loaded = !1);
          }, l.src = e ? this.fallback : this.src;
        });
    }
  },
  mounted() {
    if (!this.src)
      return J("The w-image component was used without src.");
    if (this.lazy) {
      const e = new IntersectionObserver((t) => {
        t[0] && t[0].isIntersecting && (this.loadImage(), e.disconnect());
      }, this.intersectionConfig);
      e.observe(this.$el);
    } else
      this.loadImage();
  },
  watch: {
    src() {
      this.loadImage();
    },
    width(e) {
      this.imgWidth = e;
    },
    height(e) {
      this.imgHeight = e;
    }
  }
}, vl = /* @__PURE__ */ v(wl, [["render", yl]]), kl = ["name"], _l = ["for"], Cl = ["id", "type", "name", "placeholder", "step", "min", "max", "minlength", "maxlength", "readonly", "aria-readonly", "disabled", "required", "tabindex"], Bl = ["id", "name", "multiple", "data-progress"], Sl = {
  class: "w-input__no-file",
  key: "no-file"
}, $l = ["for"], Vl = ["for"], Il = ["src"], Rl = ["for"];
function Ll(e, t, l, a, o, i) {
  const n = $("w-icon"), r = $("w-progress");
  return s(), g(V(e.formRegister ? "w-form-element" : "div"), B({ ref: "formEl" }, e.formRegister && { validators: e.validators, inputValue: o.inputValue, disabled: e.isDisabled, readonly: e.isReadonly, isFocused: o.isFocused }, {
    valid: e.valid,
    "onUpdate:valid": t[10] || (t[10] = (d) => e.valid = d),
    onReset: t[11] || (t[11] = (d) => {
      e.$emit("update:modelValue", o.inputValue = ""), e.$emit("input", "");
    }),
    wrap: i.hasLabel && l.labelPosition !== "inside",
    class: i.classes
  }), {
    default: m(() => [
      l.type === "hidden" ? D((s(), u("input", {
        key: 0,
        type: "hidden",
        name: e.name || null,
        "onUpdate:modelValue": t[0] || (t[0] = (d) => o.inputValue = d)
      }, null, 8, kl)), [
        [ge, o.inputValue]
      ]) : (s(), u(_, { key: 1 }, [
        l.labelPosition === "left" ? (s(), u(_, { key: 0 }, [
          e.$slots.default || l.label ? (s(), u("label", {
            key: 0,
            class: f(["w-input__label w-input__label--left w-form-el-shakable", e.labelClasses]),
            for: `w-input--${e._.uid}`
          }, [
            p(e.$slots, "default", {}, () => [
              C(k(l.label), 1)
            ])
          ], 10, _l)) : c("", !0)
        ], 64)) : c("", !0),
        w("div", {
          class: f(["w-input__input-wrap", i.inputWrapClasses])
        }, [
          l.innerIconLeft ? (s(), g(n, {
            key: 0,
            class: "w-input__icon w-input__icon--inner-left",
            tag: "label",
            for: `w-input--${e._.uid}`,
            onClick: t[1] || (t[1] = (d) => e.$emit("click:inner-icon-left", d))
          }, {
            default: m(() => [
              C(k(l.innerIconLeft), 1)
            ]),
            _: 1
          }, 8, ["for"])) : c("", !0),
          l.type !== "file" ? D((s(), u("input", B({
            key: 1,
            class: "w-input__input",
            ref: "input",
            "onUpdate:modelValue": t[2] || (t[2] = (d) => o.inputValue = d)
          }, N(i.listeners, !0), {
            onInput: t[3] || (t[3] = (...d) => i.onInput && i.onInput(...d)),
            onFocus: t[4] || (t[4] = (...d) => i.onFocus && i.onFocus(...d)),
            onBlur: t[5] || (t[5] = (...d) => i.onBlur && i.onBlur(...d)),
            id: `w-input--${e._.uid}`,
            type: l.type,
            name: e.inputName,
            placeholder: l.placeholder || null,
            step: l.step || null,
            min: l.min || null,
            max: l.max || null,
            minlength: l.minlength || null,
            maxlength: l.maxlength || null,
            readonly: e.isReadonly || null,
            "aria-readonly": e.isReadonly ? "true" : "false",
            disabled: e.isDisabled || null,
            required: e.required || null,
            tabindex: e.tabindex || null
          }, i.attrs), null, 16, Cl)), [
            [Se, o.inputValue]
          ]) : (s(), u(_, { key: 2 }, [
            w("input", B({
              ref: "input",
              id: `w-input--${e._.uid}`,
              type: "file",
              name: e.name || null,
              onFocus: t[6] || (t[6] = (...d) => i.onFocus && i.onFocus(...d)),
              onBlur: t[7] || (t[7] = (...d) => i.onBlur && i.onBlur(...d)),
              onChange: t[8] || (t[8] = (...d) => i.onFileChange && i.onFileChange(...d)),
              multiple: l.multiple || null
            }, i.attrs, {
              "data-progress": i.overallFilesProgress
            }), null, 16, Bl),
            I(pe, {
              class: "w-input__input w-input__input--file",
              tag: "label",
              name: "fade",
              for: `w-input--${e._.uid}`
            }, {
              default: m(() => [
                !o.inputFiles.length && o.isFocused ? (s(), u("span", Sl, [
                  p(e.$slots, "no-file", {}, () => [
                    e.$slots["no-file"] === void 0 ? (s(), u(_, { key: 0 }, [
                      C("No file")
                    ], 64)) : c("", !0)
                  ])
                ])) : c("", !0),
                (s(!0), u(_, null, T(o.inputFiles, (d, h) => (s(), u("span", {
                  key: d.lastModified
                }, [
                  C(k(h ? ", " : ""), 1),
                  (s(), u("span", {
                    class: "filename",
                    key: `${h}b`
                  }, k(d.base), 1)),
                  C(k(d.extension ? `.${d.extension}` : ""), 1)
                ]))), 128))
              ]),
              _: 3
            }, 8, ["for"])
          ], 64)),
          l.labelPosition === "inside" && i.showLabelInside ? (s(), u(_, { key: 3 }, [
            e.$slots.default || l.label ? (s(), u("label", {
              key: 0,
              class: f(["w-input__label w-input__label--inside w-form-el-shakable", e.labelClasses]),
              for: `w-input--${e._.uid}`
            }, [
              p(e.$slots, "default", {}, () => [
                C(k(l.label), 1)
              ])
            ], 10, $l)) : c("", !0)
          ], 64)) : c("", !0),
          l.innerIconRight ? (s(), g(n, {
            key: 4,
            class: "w-input__icon w-input__icon--inner-right",
            tag: "label",
            for: `w-input--${e._.uid}`,
            onClick: t[9] || (t[9] = (d) => e.$emit("click:inner-icon-right", d))
          }, {
            default: m(() => [
              C(k(l.innerIconRight), 1)
            ]),
            _: 1
          }, 8, ["for"])) : c("", !0),
          i.hasLoading || l.showProgress && (i.uploadInProgress || i.uploadComplete) ? (s(), g(r, {
            key: 5,
            class: "fill-width",
            size: "2",
            color: l.progressColor || l.color,
            "model-value": l.showProgress ? (i.uploadInProgress || i.uploadComplete) && i.overallFilesProgress : i.loadingValue
          }, null, 8, ["color", "model-value"])) : c("", !0)
        ], 2),
        l.type === "file" && l.preview && o.inputFiles.length ? (s(), u("label", {
          key: 1,
          class: "d-flex",
          for: `w-input--${e._.uid}`
        }, [
          (s(!0), u(_, null, T(o.inputFiles, (d, h) => (s(), u(_, null, [
            d.progress < 100 ? (s(), u("i", {
              class: "w-icon wi-spinner w-icon--spin size--sm w-input__file-preview primary",
              key: `${h}a`
            })) : d.preview ? (s(), u("img", {
              class: "w-input__file-preview",
              key: `${h}b`,
              src: d.preview,
              alt: ""
            }, null, 8, Il)) : (s(), u("i", {
              class: f(["w-icon w-input__file-preview primary size--md", l.preview && typeof l.preview == "string" ? l.preview : "wi-file"]),
              key: `${h}c`
            }, null, 2))
          ], 64))), 256))
        ], 8, Vl)) : c("", !0),
        l.labelPosition === "right" ? (s(), u(_, { key: 2 }, [
          e.$slots.default || l.label ? (s(), u("label", {
            key: 0,
            class: f(["w-input__label w-input__label--right w-form-el-shakable", e.labelClasses]),
            for: `w-input--${e._.uid}`
          }, [
            p(e.$slots, "default", {}, () => [
              C(k(l.label), 1)
            ])
          ], 10, Rl)) : c("", !0)
        ], 64)) : c("", !0)
      ], 64))
    ]),
    _: 3
  }, 16, ["valid", "wrap", "class"]);
}
const Tl = {
  name: "w-input",
  mixins: [z],
  props: {
    modelValue: { default: "" },
    type: { type: String, default: "text" },
    label: { type: String },
    labelPosition: { type: String, default: "inside" },
    innerIconLeft: { type: String },
    innerIconRight: { type: String },
    staticLabel: { type: Boolean },
    placeholder: { type: String },
    color: { type: String, default: "primary" },
    bgColor: { type: String },
    labelColor: { type: String, default: "primary" },
    progressColor: { type: String },
    minlength: { type: [Number, String] },
    maxlength: { type: [Number, String] },
    step: { type: [Number, String] },
    min: { type: [Number, String] },
    max: { type: [Number, String] },
    outline: { type: Boolean },
    round: { type: Boolean },
    shadow: { type: Boolean },
    tile: { type: Boolean },
    multiple: { type: Boolean },
    preview: { type: [Boolean, String], default: !0 },
    loading: { type: [Boolean, Number], default: !1 },
    showProgress: { type: [Boolean] },
    files: { type: Array },
    dark: { type: Boolean },
    light: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "focus", "blur", "click:inner-icon-left", "click:inner-icon-right", "update:overallProgress"],
  data() {
    return {
      inputValue: this.modelValue,
      inputNumberError: !1,
      isFocused: !1,
      inputFiles: [],
      fileReader: null,
      isAutofilled: !1
    };
  },
  computed: {
    attrs() {
      const { class: e, ...t } = this.$attrs;
      return t;
    },
    listeners() {
      const { input: e, focus: t, blur: l, ...a } = this.$attrs;
      return a;
    },
    hasValue() {
      switch (this.type) {
        case "file":
          return !!this.inputFiles.length;
        case "number":
          return this.inputValue || this.inputValue === 0 || this.inputNumberError;
        case "date":
        case "time":
          return !0;
        default:
          return this.inputValue || this.inputValue === 0;
      }
    },
    hasLabel() {
      return this.label || this.$slots.default;
    },
    hasLoading() {
      return ![void 0, !1].includes(this.loading);
    },
    loadingValue() {
      let e;
      return typeof this.loading == "number" ? e = this.loading : this.loading && (e = this.type === "file" && this.overallFilesProgress ? this.overallFilesProgress : void 0), e;
    },
    showLabelInside() {
      return !this.staticLabel || !this.hasValue && !this.placeholder;
    },
    overallFilesProgress() {
      const t = +this.inputFiles.reduce((l, a) => l + a.progress, 0) / this.inputFiles.length;
      return this.$emit("update:overallProgress", this.inputFiles.length ? t : void 0), t;
    },
    uploadInProgress() {
      return this.overallFilesProgress > 0 && this.overallFilesProgress < 100;
    },
    uploadComplete() {
      return this.overallFilesProgress === 100;
    },
    classes() {
      return {
        "w-input": !0,
        "w-input--file": this.type === "file",
        "w-input--disabled": this.isDisabled,
        "w-input--readonly": this.isReadonly,
        [`w-input--${this.hasValue || this.isAutofilled ? "filled" : "empty"}`]: !0,
        "w-input--focused": this.isFocused && !this.isReadonly,
        "w-input--dark": this.dark,
        "w-input--light": this.light,
        "w-input--floating-label": this.hasLabel && this.labelPosition === "inside" && !this.staticLabel,
        "w-input--no-padding": !this.outline && !this.bgColor && !this.shadow && !this.round,
        "w-input--has-placeholder": this.placeholder,
        "w-input--inner-icon-left": this.innerIconLeft,
        "w-input--inner-icon-right": this.innerIconRight
      };
    },
    inputWrapClasses() {
      return {
        [this.valid === !1 ? this.validationColor : this.color]: this.color || this.valid === !1,
        [`${this.bgColor}--bg`]: this.bgColor,
        "w-input__input-wrap--file": this.type === "file",
        "w-input__input-wrap--round": this.round,
        "w-input__input-wrap--tile": this.tile,
        "w-input__input-wrap--box": this.outline || this.bgColor || this.shadow,
        "w-input__input-wrap--underline": !this.outline,
        "w-input__input-wrap--shadow": this.shadow,
        "w-input__input-wrap--no-padding": !this.outline && !this.bgColor && !this.shadow && !this.round,
        "w-input__input-wrap--loading": this.loading || this.showProgress && this.uploadInProgress,
        "w-input__input-wrap--upload-complete": this.uploadComplete
      };
    }
  },
  methods: {
    onInput(e) {
      this.inputNumberError = e.target.validity.badInput, this.$emit("update:modelValue", this.inputValue), this.$emit("input", this.inputValue);
    },
    onFocus(e) {
      this.isFocused = !0, this.$emit("focus", e);
    },
    onBlur(e) {
      this.isFocused = !1, this.$emit("blur", e);
    },
    onFileChange(e) {
      this.inputFiles = [...e.target.files].map((t) => {
        const [, l = "", a = "", o = ""] = t.name.match(/^(.*?)\.([^.]*)$|(.*)/), i = G({
          name: t.name,
          base: l || o,
          extension: a,
          type: t.type,
          size: t.size,
          lastModified: t.lastModified,
          preview: null,
          progress: 0,
          file: t
        });
        return this.readFile(t, i), i;
      }), this.$emit("update:modelValue", this.inputFiles), this.$emit("input", this.inputFiles);
    },
    readFile(e, t) {
      const l = new FileReader(), a = typeof this.preview == "string", o = e.type && e.type.startsWith("image/");
      this.preview && !a && o ? l.addEventListener("load", (i) => {
        t.preview = i.target.result;
      }) : delete t.preview, l.addEventListener("progress", (i) => {
        i.loaded && i.total && (t.progress = i.loaded * 100 / i.total);
      }), l.readAsDataURL(e);
    }
  },
  mounted() {
    setTimeout(() => {
      this.$refs.input && this.$refs.input.matches(":-webkit-autofill") && (this.isAutofilled = !0);
    }, 400);
  },
  watch: {
    modelValue(e) {
      this.inputValue = e, !e && e !== 0 && (this.isAutofilled = !1);
    }
  }
}, xl = /* @__PURE__ */ v(Tl, [["render", Ll]]);
function Pl(e, t, l, a, o, i) {
  const n = $("w-icon"), r = $("w-list", !0);
  return s(), u("ul", {
    class: f(["w-list", i.classes])
  }, [
    (s(!0), u(_, null, T(e.listItems, (d, h) => (s(), u("li", {
      class: f(["w-list__item", { "w-list__item--parent": (d.children || []).length }]),
      key: h
    }, [
      l.icon ? (s(), g(n, {
        key: 0,
        class: "w-list__item-bullet"
      }, {
        default: m(() => [
          C(k(l.icon), 1)
        ]),
        _: 1
      })) : c("", !0),
      e.$slots[`item.${h + 1}`] || e.$slots.item || e.$slots.default ? (s(), g(V(l.checklist ? "w-checkbox" : l.nav && !d.disabled && d.route ? i.hasRouter ? "router-link" : "a" : "div"), B({
        key: 1,
        class: "w-list__item-label"
      }, i.liLabelProps(d, h, d._selected)), {
        default: m(() => [
          e.$slots[`item.${h + 1}`] ? p(e.$slots, `item.${h + 1}`, {
            key: 0,
            item: i.cleanLi(d),
            index: h + 1,
            selected: d._selected
          }) : e.$slots.item ? p(e.$slots, "item", {
            key: 1,
            item: i.cleanLi(d),
            index: h + 1,
            selected: d._selected
          }) : p(e.$slots, "default", {
            key: 2,
            item: i.cleanLi(d),
            index: h + 1,
            selected: d._selected
          }, () => [
            C(k(d._label), 1)
          ])
        ]),
        _: 2
      }, 1040)) : (s(), g(V(l.checklist ? "w-checkbox" : l.nav && !d.disabled && d.route ? i.hasRouter ? "router-link" : "a" : "div"), B({
        key: 2,
        class: "w-list__item-label"
      }, i.liLabelProps(d, h, d._selected)), null, 16)),
      (d.children || []).length ? (s(), g(r, B({ key: 3 }, e.$props, {
        items: d.children,
        depth: l.depth + 1,
        "onUpdate:modelValue": t[0] || (t[0] = (y) => e.$emit("update:modelValue", y)),
        onInput: t[1] || (t[1] = (y) => e.$emit("input", y)),
        onItemClick: t[2] || (t[2] = (y) => e.$emit("item-click", y)),
        onItemSelect: t[3] || (t[3] = (y) => e.$emit("item-select", y))
      }), Z({ _: 2 }, [
        e.$slots.item ? {
          name: "item",
          fn: m(({ item: y, index: S, selected: b }) => [
            p(e.$slots, "item", {
              item: i.cleanLi(y),
              index: S,
              selected: b
            })
          ]),
          key: "0"
        } : {
          name: "default",
          fn: m(({ item: y, index: S, selected: b }) => [
            p(e.$slots, "default", {
              item: i.cleanLi(y),
              index: S,
              selected: b
            }, () => [
              C(k(y[l.itemLabelKey]), 1)
            ])
          ]),
          key: "1"
        }
      ]), 1040, ["items", "depth"])) : c("", !0)
    ], 2))), 128))
  ], 2);
}
const Ol = {
  name: "w-list",
  props: {
    items: { type: [Array, Number], required: !0 },
    modelValue: {},
    checklist: { type: Boolean },
    roundCheckboxes: { type: Boolean },
    multiple: { type: Boolean },
    addIds: { type: [Boolean, String] },
    hover: { type: Boolean },
    color: { type: String },
    selectionColor: { type: String },
    bgColor: { type: String },
    nav: { type: Boolean },
    icon: { type: String, default: "" },
    itemLabelKey: { type: String, default: "label" },
    itemValueKey: { type: String, default: "value" },
    itemClassKey: { type: String, default: "class" },
    itemColorKey: { type: String, default: "color" },
    itemRouteKey: { type: String, default: "route" },
    itemClass: { type: String },
    depth: { type: Number, default: 0 },
    returnObject: { type: Boolean },
    noUnselect: { type: Boolean },
    arrowsNavigation: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "item-click", "item-select", "keydown:escape", "keydown:enter"],
  data: () => ({
    listItems: []
  }),
  computed: {
    hasRouter() {
      return "$router" in this;
    },
    listId() {
      return this.addIds ? typeof this.addIds == "string" ? this.addIds : `w-list--${this._.uid}` : null;
    },
    selectedItems() {
      return this.listItems.filter((e) => e._selected);
    },
    enabledItemsIndexes() {
      return this.listItems.filter((e) => !e.disabled).map((e) => e.index);
    },
    isMultipleSelect() {
      return this.multiple || this.checklist;
    },
    isSelectable() {
      return this.modelValue !== void 0 || this.checklist || this.nav;
    },
    SelectionColor() {
      const e = this.selectionColor === void 0 ? !this.color && "primary" : this.selectionColor;
      return this.isSelectable && e;
    },
    classes() {
      return {
        [this.color]: this.color || null,
        [`${this.bgColor}--bg`]: this.bgColor || null,
        "w-list--checklist": this.checklist,
        "w-list--navigation": this.nav,
        "w-list--icon": this.icon,
        [`w-list--child w-list--depth-${this.depth}`]: this.depth
      };
    }
  },
  methods: {
    getItemValue(e) {
      return e && typeof e == "object" ? e[this.itemValueKey] !== void 0 ? e[this.itemValueKey] : e[this.itemLabelKey] !== void 0 ? e[this.itemLabelKey] : e.index : e;
    },
    selectItem(e, t) {
      e._selected && !this.multiple && this.noUnselect || (e._selected = t !== void 0 ? t : !e._selected, e._selected && !this.isMultipleSelect && this.listItems.forEach((l) => l._index !== e._index && (l._selected = !1)), this.emitSelection());
    },
    liLabelClasses(e) {
      return {
        "w-list__item-label--disabled": e.disabled || this.nav && !e[this.itemRouteKey] && !e.children,
        "w-list__item-label--active": this.isSelectable && e._selected || null,
        "w-list__item-label--focused": e._focused,
        "w-list__item-label--hoverable": this.hover,
        "w-list__item-label--selectable": this.isSelectable,
        [e.color]: !!e.color,
        [this.SelectionColor]: e._selected && !e.color && this.SelectionColor,
        [e[this.itemClassKey] || this.itemClass]: e[this.itemClassKey] || this.itemClass
      };
    },
    liLabelProps(e, t, l) {
      const a = this.$slots[`item.${t + 1}`] || this.$slots.item, o = () => {
        if (!e.disabled) {
          const d = this.cleanLi(e);
          this.$emit("item-click", d), this.$emit("item-select", d);
        }
      }, i = this.isSelectable && ((d) => {
        d.stopPropagation(), !e.disabled && this.selectItem(e);
      }), n = this.isSelectable && ((d) => {
        !e.disabled && d.keyCode === 13 ? (this.selectItem(e), this.$emit("keydown:enter"), this.$emit("item-select", this.cleanLi(e))) : d.keyCode === 27 ? this.$emit("keydown:escape") : this.arrowsNavigation && [38, 40].includes(d.keyCode) && (d.preventDefault(), d.keyCode === 38 && this.focusPrevNextItem(e._index, !1), d.keyCode === 40 && this.focusPrevNextItem(e._index, !0));
      }), r = {
        class: this.liLabelClasses(e),
        tabindex: e.disabled || this.checklist ? null : "0",
        "aria-selected": l ? "true" : "false",
        id: this.listId ? `${this.listId}_item-${t + 1}` : null,
        role: "option"
      };
      return this.checklist ? (r.modelValue = e._selected, r.color = e[this.itemColorKey] || this.color, r.round = this.roundCheckboxes, r.disabled = e.disabled, a || (r.label = e._label || null), r.onFocus = () => e._focused = !0, r.onBlur = () => e._focused = !1, r.onInput = (d) => this.selectItem(e, d), r.onClick = (d) => {
        const h = d.target.querySelector('input[type="checkbox"]');
        h && (h.focus(), h.click()), o();
      }) : this.nav ? (!e.disabled && e[this.itemRouteKey] && (r.onKeydown = n, r.onMousedown = i, this.$router ? (r.to = e[this.itemRouteKey], r.onClick = (d) => {
        d.preventDefault(), this.$router.push(e[this.itemRouteKey]), o();
      }) : (r.href = e[this.itemRouteKey], r.onClick = o)), a || (r.innerHTML = e._label)) : (this.isSelectable && (e.disabled || (r.tabindex = 0), r.onClick = o, r.onKeydown = n, r.onMousedown = i), a || (r.innerHTML = e._label)), r;
    },
    checkSelection(e) {
      return e = Array.isArray(e) ? e : e ? [e] : [], this.returnObject && (e = e.map(this.getItemValue)), e;
    },
    emitSelection() {
      const e = this.selectedItems.map((l) => {
        if (!this.returnObject)
          return l._value;
        const { _value: a, _selected: o, ...i } = l;
        return i;
      }), t = this.isMultipleSelect ? e : e[0] !== void 0 ? e[0] : null;
      this.$emit("update:modelValue", t), this.$emit("input", t);
    },
    focusPrevNextItem(e, t = !0) {
      e = this.enabledItemsIndexes[this.enabledItemsIndexes.indexOf(e) + (t ? 1 : -1)];
      const l = t ? 0 : this.enabledItemsIndexes.length - 1;
      e === void 0 && (e = this.enabledItemsIndexes[l]), this.$el.querySelector(`#${this.listId}_item-${e + 1}`).focus();
    },
    cleanLi(e) {
      const { _index: t, _value: l, _label: a, _selected: o, _focused: i, ...n } = e;
      return n;
    },
    refreshListItems() {
      const e = typeof this.items == "number" ? Array(this.items).fill({}) : this.items || [];
      this.listItems = e.map((t, l) => ({
        ...t,
        _index: l,
        _value: t[this.itemValueKey] === void 0 ? t[this.itemLabelKey] || l : t[this.itemValueKey],
        _selected: t._selected || !1,
        _label: t[this.itemLabelKey] || "",
        _focused: !1
      }));
    },
    applySelectionOnItems(e) {
      this.isMultipleSelect || this.listItems.forEach((t) => t._selected = !1), this.checkSelection(e).forEach((t) => {
        const l = this.listItems.find((a) => a._value === t);
        l && (l._selected = !0);
      });
    }
  },
  created() {
    this.refreshListItems(), this.applySelectionOnItems(this.modelValue);
  },
  watch: {
    items() {
      this.refreshListItems(), this.applySelectionOnItems(this.modelValue);
    },
    modelValue(e) {
      this.applySelectionOnItems(e);
    },
    multiple(e) {
      if (!e) {
        let t = null;
        this.listItems.forEach((l) => {
          l._selected && !t ? t = l : l._selected && (l._selected = !1);
        }), this.emitSelection();
      }
    }
  }
}, zl = /* @__PURE__ */ v(Ol, [["render", Pl]]), ye = {
  props: {
    appendTo: { type: [String, Boolean, Object] },
    fixed: { type: Boolean },
    top: { type: Boolean },
    bottom: { type: Boolean },
    left: { type: Boolean },
    right: { type: Boolean },
    alignTop: { type: Boolean },
    alignBottom: { type: Boolean },
    alignLeft: { type: Boolean },
    alignRight: { type: Boolean },
    noPosition: { type: Boolean },
    zIndex: { type: [Number, String, Boolean] },
    activator: { type: [String, Object] }
  },
  inject: {
    detachableDefaultRoot: { default: null }
  },
  data: () => ({
    docEventListenersHandlers: []
  }),
  computed: {
    appendToTarget() {
      let e = ".w-app";
      typeof this.detachableDefaultRoot == "function" && (e = this.detachableDefaultRoot() || e);
      let t = this.appendTo || e;
      return t === !0 ? t = e : this.appendTo === "activator" ? t = this.$el.previousElementSibling : t && !["object", "string"].includes(typeof t) ? t = e : typeof t == "object" && !t.nodeType && (t = e, J(`Invalid node provided in ${this.$options.name} \`append-to\`. Falling back to .w-app.`)), typeof t == "string" && (t = document.querySelector(t)), t || (J(`Unable to locate ${this.appendTo ? `target ${this.appendTo}` : e}`), t = document.querySelector(e)), t;
    },
    detachableParentEl() {
      return this.appendToTarget;
    },
    hasSeparateActivator() {
      var l;
      if (this.$slots.activator)
        return !1;
      const e = typeof this.activator == "string", t = (((l = this.activator) == null ? void 0 : l.$el) || this.activator) instanceof HTMLElement;
      return e || t;
    },
    activatorEl: {
      get() {
        var e;
        if (this.hasSeparateActivator) {
          const t = ((e = this.activator) == null ? void 0 : e.$el) || this.activator;
          return t instanceof HTMLElement ? t : document.querySelector(this.activator);
        }
        return this.$el.nextElementSibling;
      },
      set() {
      }
    },
    position() {
      return this.top && "top" || this.bottom && "bottom" || this.left && "left" || this.right && "right" || "bottom";
    },
    alignment() {
      return ["top", "bottom"].includes(this.position) && this.alignLeft && "left" || ["top", "bottom"].includes(this.position) && this.alignRight && "right" || ["left", "right"].includes(this.position) && this.alignTop && "top" || ["left", "right"].includes(this.position) && this.alignBottom && "bottom" || "";
    }
  },
  methods: {
    async open(e) {
      this.delay && await new Promise((t) => setTimeout(t, this.delay)), this.detachableVisible = !0, this.activator && (this.activatorEl = e.target), await this.insertInDOM(), this.minWidth === "activator" && (this.activatorWidth = this.activatorEl.offsetWidth), this.noPosition || this.computeDetachableCoords(), this.timeoutId = setTimeout(() => {
        this.$emit("update:modelValue", !0), this.$emit("input", !0), this.$emit("open");
      }, 0), this.persistent || document.addEventListener("mousedown", this.onOutsideMousedown), this.noPosition || window.addEventListener("resize", this.onResize);
    },
    getActivatorCoordinates() {
      const { top: e, left: t, width: l, height: a } = this.activatorEl.getBoundingClientRect();
      let o = { top: e, left: t, width: l, height: a };
      if (!this.fixed) {
        const { top: i, left: n } = this.detachableParentEl.getBoundingClientRect(), r = window.getComputedStyle(this.detachableParentEl, null);
        o = {
          ...o,
          top: e - i + this.detachableParentEl.scrollTop - parseInt(r.getPropertyValue("border-top-width")),
          left: t - n + this.detachableParentEl.scrollLeft - parseInt(r.getPropertyValue("border-left-width"))
        };
      }
      return o;
    },
    computeDetachableCoords() {
      let { top: e, left: t, width: l, height: a } = this.getActivatorCoordinates();
      if (!this.detachableEl)
        return;
      this.detachableEl.style.visibility = "hidden", this.detachableEl.style.display = "flex";
      const o = window.getComputedStyle(this.detachableEl, null);
      switch (this.position) {
        case "top": {
          e -= this.detachableEl.offsetHeight, this.alignRight ? t += l - this.detachableEl.offsetWidth + parseInt(o.getPropertyValue("border-right-width")) : this.alignLeft || (t += (l - this.detachableEl.offsetWidth) / 2);
          break;
        }
        case "bottom": {
          e += a, this.alignRight ? t += l - this.detachableEl.offsetWidth + parseInt(o.getPropertyValue("border-right-width")) : this.alignLeft || (t += (l - this.detachableEl.offsetWidth) / 2);
          break;
        }
        case "left": {
          t -= this.detachableEl.offsetWidth, this.alignBottom ? e += a - this.detachableEl.offsetHeight : this.alignTop || (e += (a - this.detachableEl.offsetHeight) / 2);
          break;
        }
        case "right": {
          t += l, this.alignBottom ? e += a - this.detachableEl.offsetHeight + parseInt(o.getPropertyValue("margin-top")) : this.alignTop || (e += (a - this.detachableEl.offsetHeight) / 2 + parseInt(o.getPropertyValue("margin-top")));
          break;
        }
      }
      this.detachableEl.style.visibility = null, this.detachableVisible || (this.detachableEl.style.display = "none"), this.detachableCoords = { top: e, left: t };
    },
    onResize() {
      this.minWidth === "activator" && (this.activatorWidth = this.activatorEl.offsetWidth), this.computeDetachableCoords();
    },
    onOutsideMousedown(e) {
      !this.detachableEl.contains(e.target) && !this.activatorEl.contains(e.target) && (this.$emit("update:modelValue", this.detachableVisible = !1), this.$emit("input", !1), this.$emit("close"), document.removeEventListener("mousedown", this.onOutsideMousedown), window.removeEventListener("resize", this.onResize));
    },
    insertInDOM() {
      return new Promise((e) => {
        this.$nextTick(() => {
          var t;
          this.detachableEl = ((t = this.$refs.detachable) == null ? void 0 : t.$el) || this.$refs.detachable, this.detachableEl && this.appendToTarget.appendChild(this.detachableEl), e();
        });
      });
    },
    removeFromDOM() {
      document.removeEventListener("mousedown", this.onOutsideMousedown), window.removeEventListener("resize", this.onResize), this.detachableEl && this.detachableEl.parentNode && (this.detachableVisible = !1, this.detachableEl.remove(), this.detachableEl = null);
    },
    bindActivatorEvents() {
      const e = typeof this.activator == "string";
      Object.entries(this.activatorEventHandlers).forEach(([t, l]) => {
        t = t.replace("mouseenter", "mouseover").replace("mouseleave", "mouseout");
        const a = (o) => {
          var i;
          (e && ((i = o.target) == null ? void 0 : i.matches) && o.target.matches(this.activator) || o.target === this.activatorEl || this.activatorEl.contains(o.target)) && l(o);
        };
        document.addEventListener(t, a), this.docEventListenersHandlers.push({ eventName: t, handler: a });
      });
    }
  },
  mounted() {
    var e;
    this.activator ? this.bindActivatorEvents() : this.$nextTick(() => {
      this.activator && this.bindActivatorEvents(), this.modelValue && this.toggle({ type: "click", target: this.activatorEl });
    }), this.overlay && (this.overlayEl = (e = this.$refs.overlay) == null ? void 0 : e.$el), this.modelValue && this.activator && this.toggle({ type: "click", target: this.activatorEl });
  },
  unmounted() {
    this.close(), this.removeFromDOM(), this.docEventListenersHandlers.length && this.docEventListenersHandlers.forEach(({ eventName: e, handler: t }) => {
      document.removeEventListener(e, t);
    });
  },
  watch: {
    modelValue(e) {
      !!e !== this.detachableVisible && this.toggle({ type: "click", target: this.activatorEl });
    },
    appendTo() {
      this.removeFromDOM(), this.insertInDOM();
    }
  }
};
function El(e, t, l, a, o, i) {
  const n = $("w-card"), r = $("w-overlay");
  return s(), u(_, null, [
    p(e.$slots, "activator", { on: i.activatorEventHandlers }),
    I(x, {
      name: i.transitionName,
      appear: ""
    }, {
      default: m(() => [
        l.custom && e.detachableVisible ? (s(), u("div", B({
          key: 0,
          class: "w-menu",
          ref: "detachable"
        }, e.$attrs, {
          onClick: t[0] || (t[0] = (d) => l.hideOnMenuClick && i.close(!0)),
          onMouseenter: t[1] || (t[1] = (d) => l.showOnHover && (e.hoveringMenu = !0)),
          onMouseleave: t[2] || (t[2] = (d) => l.showOnHover && (e.hoveringMenu = !1, i.close())),
          class: i.classes,
          style: i.styles
        }), [
          p(e.$slots, "default")
        ], 16)) : e.detachableVisible ? (s(), g(n, B({
          key: 1,
          class: "w-menu",
          ref: "detachable"
        }, e.$attrs, {
          onClick: t[3] || (t[3] = (d) => l.hideOnMenuClick && i.close(!0)),
          onMouseenter: t[4] || (t[4] = (d) => l.showOnHover && (e.hoveringMenu = !0)),
          onMouseleave: t[5] || (t[5] = (d) => l.showOnHover && (e.hoveringMenu = !1, i.close())),
          tile: l.tile,
          "title-class": i.titleClasses,
          "content-class": i.contentClasses,
          shadow: l.shadow,
          "no-border": l.noBorder,
          class: i.classes,
          style: i.styles
        }), Z({
          default: m(() => [
            p(e.$slots, "default")
          ]),
          _: 2
        }, [
          e.$slots.title ? {
            name: "title",
            fn: m(() => [
              p(e.$slots, "title")
            ]),
            key: "0"
          } : void 0,
          e.$slots.actions ? {
            name: "actions",
            fn: m(() => [
              p(e.$slots, "actions")
            ]),
            key: "1"
          } : void 0
        ]), 1040, ["tile", "title-class", "content-class", "shadow", "no-border", "class", "style"])) : c("", !0)
      ]),
      _: 3
    }, 8, ["name"]),
    l.overlay ? (s(), g(r, B({
      key: 0,
      ref: "overlay",
      "model-value": e.detachableVisible,
      persistent: l.persistent,
      class: i.overlayClasses
    }, l.overlayProps, {
      "z-index": (e.zIndex || 200) - 1,
      "onUpdate:modelValue": t[6] || (t[6] = (d) => e.detachableVisible = !1)
    }), null, 16, ["model-value", "persistent", "class", "z-index"])) : c("", !0)
  ], 64);
}
const Ml = {
  name: "w-menu",
  mixins: [ye],
  inheritAttrs: !1,
  props: {
    modelValue: {},
    showOnHover: { type: Boolean },
    hideOnMenuClick: { type: Boolean },
    color: { type: String },
    bgColor: { type: String },
    shadow: { type: Boolean },
    custom: { type: Boolean },
    tile: { type: Boolean },
    round: { type: Boolean },
    noBorder: { type: Boolean },
    transition: { type: String },
    menuClass: { type: [String, Object, Array] },
    titleClass: { type: [String, Object, Array] },
    contentClass: { type: [String, Object, Array] },
    arrow: { type: Boolean },
    minWidth: { type: [Number, String] },
    overlay: { type: Boolean },
    overlayClass: { type: [String, Object, Array] },
    overlayProps: { type: Object },
    persistent: { type: Boolean },
    delay: { type: Number },
    dark: { type: Boolean },
    light: { type: Boolean }
  },
  provide() {
    return {
      detachableDefaultRoot: () => {
        var e;
        return ((e = this.$refs.detachable) == null ? void 0 : e.$el) || this.$refs.detachable || null;
      }
    };
  },
  emits: ["input", "update:modelValue", "open", "close"],
  data: () => ({
    detachableVisible: !1,
    hoveringActivator: !1,
    hoveringMenu: !1,
    detachableCoords: {
      top: 0,
      left: 0
    },
    activatorWidth: 0,
    detachableEl: null,
    timeoutId: null
  }),
  computed: {
    transitionName() {
      return this.transition || "scale-fade";
    },
    menuMinWidth() {
      return this.minWidth === "activator" ? this.activatorWidth ? `${this.activatorWidth}px` : 0 : isNaN(this.minWidth) ? this.minWidth : this.minWidth ? `${this.minWidth}px` : 0;
    },
    menuClasses() {
      return W(this.menuClass);
    },
    titleClasses() {
      return W(this.titleClass);
    },
    contentClasses() {
      return W(this.contentClass);
    },
    overlayClasses() {
      return {
        ...W(this.overlayClass),
        "w-overlay--no-pointer-event": this.showOnHover
      };
    },
    classes() {
      return {
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor,
        ...this.menuClasses,
        [`w-menu--${this.position}`]: !this.noPosition,
        [`w-menu--align-${this.alignment}`]: !this.noPosition && this.alignment,
        "w-menu--tile": this.tile,
        "w-menu--card": !this.custom,
        "w-menu--round": this.round,
        "w-menu--arrow": this.arrow,
        "w-menu--shadow": this.shadow,
        "w-menu--fixed": this.fixed,
        "w-menu--dark": this.dark,
        "w-menu--light": this.light
      };
    },
    styles() {
      return {
        zIndex: this.zIndex || this.zIndex === 0 || this.overlay && !this.zIndex && 200 || null,
        top: this.detachableCoords.top && `${~~this.detachableCoords.top}px` || null,
        left: this.detachableCoords.left && `${~~this.detachableCoords.left}px` || null,
        minWidth: this.minWidth && this.menuMinWidth || null,
        "--w-menu-bg-color": this.arrow && this.$waveui.colors[this.bgColor || "white"]
      };
    },
    activatorEventHandlers() {
      let e = {};
      return this.showOnHover ? (e = {
        focus: this.toggle,
        blur: this.toggle,
        mouseenter: (t) => {
          this.hoveringActivator = !0, this.open(t);
        },
        mouseleave: (t) => {
          this.hoveringActivator = !1, setTimeout(() => {
            this.hoveringMenu || this.close();
          }, 10);
        }
      }, typeof window < "u" && "ontouchstart" in window && (e.click = this.toggle)) : e = { click: this.toggle }, e;
    }
  },
  methods: {
    toggle(e) {
      let t = this.detachableVisible;
      typeof window < "u" && "ontouchstart" in window && this.showOnHover && e.type === "click" || e.type === "click" && !this.showOnHover ? t = !t : e.type === "mouseenter" && this.showOnHover ? (this.hoveringActivator = !0, t = !0) : e.type === "mouseleave" && this.showOnHover && (this.hoveringActivator = !1, t = !1), this.timeoutId = clearTimeout(this.timeoutId), t ? this.open(e) : this.close();
    },
    async close(e = !1) {
      !this.detachableVisible || this.showOnHover && !e && (await new Promise((t) => setTimeout(t, 10)), this.showOnHover && (this.hoveringMenu || this.hoveringActivator)) || (this.$emit("update:modelValue", this.detachableVisible = !1), this.$emit("input", !1), this.$emit("close"), document.removeEventListener("mousedown", this.onOutsideMousedown), window.removeEventListener("resize", this.onResize));
    }
  }
}, Nl = /* @__PURE__ */ v(Ml, [["render", El]]);
function Wl(e, t, l, a, o, i) {
  const n = $("w-alert");
  return s(), g(x, {
    name: i.transitionName,
    appear: ""
  }, {
    default: m(() => [
      o.show ? (s(), u("div", {
        key: 0,
        class: f(["w-notification", i.classes]),
        style: L(i.styles)
      }, [
        I(n, B(i.alertProps, {
          class: i.alertClasses,
          "onUpdate:modelValue": t[0] || (t[0] = (r) => {
            e.$emit("update:modelValue", !1), e.$emit("input", !1);
          })
        }), {
          default: m(() => [
            p(e.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ], 6)) : c("", !0)
    ]),
    _: 3
  }, 8, ["name"]);
}
const Al = {
  name: "w-notification",
  props: {
    modelValue: { default: !0 },
    transition: { type: [String, Boolean], default: "" },
    timeout: { type: [Number, String], default: 0 },
    absolute: { type: Boolean },
    top: { type: Boolean },
    bottom: { type: Boolean },
    left: { type: Boolean },
    right: { type: Boolean },
    zIndex: { type: [Number, String, Boolean] },
    success: { type: Boolean },
    info: { type: Boolean },
    warning: { type: Boolean },
    error: { type: Boolean },
    color: { type: String },
    bgColor: { type: String },
    shadow: { type: Boolean },
    tile: { type: Boolean },
    round: { type: Boolean },
    plain: { type: Boolean },
    noBorder: { type: Boolean },
    borderLeft: { type: Boolean },
    borderRight: { type: Boolean },
    borderTop: { type: Boolean },
    borderBottom: { type: Boolean },
    outline: { type: Boolean },
    dismiss: { type: Boolean },
    xs: { type: Boolean },
    sm: { type: Boolean },
    md: { type: Boolean },
    lg: { type: Boolean },
    xl: { type: Boolean },
    dark: { type: Boolean },
    light: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "close"],
  data() {
    return {
      show: this.modelValue,
      timeoutId: null
    };
  },
  computed: {
    transitionName() {
      return this.transition === !1 ? "" : this.transition ? this.transition : `slide-${{ top: "down", bottom: "up", left: "right", right: "left" }[this.position[this.position[1] === "center" ? 0 : 1]]}`;
    },
    position() {
      let e = [];
      return !this.top && !this.bottom && !this.left && !this.right ? e = ["top", "right"] : e = [
        this.top && "top" || this.bottom && "bottom" || "top",
        this.left && "left" || this.right && "right" || "center"
      ], e;
    },
    hasType() {
      return !!(this.success || this.info || this.warning || this.error);
    },
    alertProps() {
      return {
        modelValue: this.show,
        success: this.success,
        info: this.info,
        warning: this.warning,
        error: this.error,
        color: this.color,
        bgColor: this.bgColor || !this.hasType && "white" || "",
        shadow: this.shadow,
        tile: this.tile,
        round: this.round,
        plain: this.plain,
        noBorder: this.noBorder,
        borderLeft: this.borderLeft,
        borderRight: this.borderRight,
        borderTop: this.borderTop,
        borderBottom: this.borderBottom,
        outline: this.outline,
        dismiss: this.dismiss,
        xs: this.xs,
        sm: this.sm,
        md: this.md,
        lg: this.lg,
        xl: this.xl
      };
    },
    classes() {
      return {
        "w-notification--dark": this.dark,
        "w-notification--light": this.light,
        "w-notification--absolute": this.absolute,
        [`w-notification--${this.position.join(" w-notification--")}`]: !0
      };
    },
    alertClasses() {
      return this.bgColor || (this.success || this.info || this.warning || this.error) && this.plain ? null : "white--bg";
    },
    styles() {
      return {
        zIndex: this.zIndex || this.zIndex === 0 || null
      };
    },
    timeoutVal() {
      return parseInt(this.timeout);
    }
  },
  methods: {
    countdown() {
      this.timeoutId = setTimeout(() => {
        this.$emit("update:modelValue", this.show = !1), this.$emit("input", !1), this.$emit("close");
      }, this.timeoutVal);
    }
  },
  created() {
    this.modelValue && this.timeoutVal && this.countdown();
  },
  watch: {
    modelValue(e) {
      clearTimeout(this.timeoutId), this.show = e, e && this.timeoutVal && this.countdown();
    }
  }
}, Kl = /* @__PURE__ */ v(Al, [["render", Wl]]);
function Dl(e, t, l, a, o, i) {
  const n = fe("focus");
  return s(), g(x, {
    name: "fade",
    appear: "",
    onAfterLeave: i.onClose
  }, {
    default: m(() => [
      l.modelValue ? D((s(), u("div", {
        key: 0,
        class: f(["w-overlay", i.classes]),
        ref: "overlay",
        style: L(l.modelValue && i.styles || null),
        onKeydown: t[0] || (t[0] = M(E((...r) => i.onClick && i.onClick(...r), ["stop"]), ["escape"])),
        onClick: t[1] || (t[1] = (...r) => i.onClick && i.onClick(...r)),
        tabindex: "0"
      }, [
        p(e.$slots, "default")
      ], 38)), [
        [me, e.showOverlay],
        [n]
      ]) : c("", !0)
    ]),
    _: 3
  }, 8, ["onAfterLeave"]);
}
const Fl = {
  name: "w-overlay",
  props: {
    modelValue: {},
    opacity: { type: [Number, String, Boolean] },
    bgColor: { type: String },
    absolute: { type: Boolean },
    zIndex: { type: [Number, String, Boolean] },
    persistent: { type: Boolean },
    persistentNoAnimation: { type: Boolean }
  },
  provide() {
    return {
      detachableDefaultRoot: () => this.$refs.overlay || null
    };
  },
  emits: ["input", "update:modelValue", "click", "before-close", "close"],
  data: () => ({
    persistentAnimate: !1,
    showOverlay: !1
  }),
  computed: {
    backgroundColor() {
      return this.bgColor || this.opacity && `rgba(0, 0, 0, ${this.opacity})` || !1;
    },
    classes() {
      return {
        "w-overlay--persistent-animate": this.persistentAnimate,
        "w-overlay--absolute": this.absolute
      };
    },
    styles() {
      return {
        backgroundColor: this.backgroundColor,
        zIndex: this.zIndex || this.zIndex === 0 ? this.zIndex : !1
      };
    }
  },
  methods: {
    onClick(e) {
      !e.target.classList.contains("w-overlay") || (this.persistent && !this.persistentNoAnimation ? (this.persistentAnimate = !0, setTimeout(() => this.persistentAnimate = !1, 150)) : this.persistent || (this.showOverlay = !1, this.$emit("before-close")), this.$emit("click", e));
    },
    onClose() {
      this.$emit("update:modelValue", !1), this.$emit("input", !1), this.modelValue || this.$emit("close");
    }
  },
  created() {
    this.showOverlay = this.modelValue;
  },
  watch: {
    modelValue(e) {
      e && (this.showOverlay = !0);
    }
  }
}, Hl = /* @__PURE__ */ v(Fl, [["render", Dl]]), jl = { class: "w-parallax" };
function Ul(e, t, l, a, o, i) {
  return s(), u("div", jl);
}
const ql = {
  name: "w-parallax",
  props: {},
  emits: [],
  data: () => ({})
}, Gl = /* @__PURE__ */ v(ql, [["render", Ul]]), Xl = ["viewBox"], Yl = ["cx", "cy", "r", "stroke-dasharray", "stroke-width"], Jl = ["cx", "cy", "r", "stroke-width", "stroke-linecap", "stroke-dasharray"];
function Ql(e, t, l, a, o, i) {
  return s(), u("div", {
    class: f(["w-progress", i.classes]),
    style: L(i.styles)
  }, [
    l.circle ? (s(), u("svg", {
      key: 1,
      viewBox: `${i.circleCenter / 2} ${i.circleCenter / 2} ${i.circleCenter} ${i.circleCenter}`
    }, [
      l.bgColor || this.progressValue > -1 ? (s(), u("circle", {
        key: 0,
        class: f(["bg", l.bgColor || null]),
        cx: i.circleCenter,
        cy: i.circleCenter,
        r: e.circleRadius,
        fill: "transparent",
        "stroke-dasharray": e.circleCircumference,
        "stroke-width": l.stroke
      }, null, 10, Yl)) : c("", !0),
      w("circle", {
        class: "w-progress__progress",
        cx: i.circleCenter,
        cy: i.circleCenter,
        r: e.circleRadius,
        fill: "transparent",
        "stroke-width": l.stroke,
        "stroke-linecap": l.roundCap && "round",
        "stroke-dasharray": e.circleCircumference,
        style: L(`stroke-dashoffset: ${(1 - i.progressValue / 100) * e.circleCircumference}`)
      }, null, 12, Jl)
    ], 8, Xl)) : (s(), u("div", {
      key: 0,
      class: f(["w-progress__progress", { full: i.progressValue === 100 }]),
      style: L(`width: ${i.progressValue}%`)
    }, null, 6)),
    l.label || e.$slots.default ? (s(), u("div", {
      key: 2,
      class: f(["w-progress__label", l.labelColor || !1])
    }, [
      p(e.$slots, "default", {}, () => [
        C(k(Math.round(i.progressValue)) + k(l.circle ? "" : "%"), 1)
      ])
    ], 2)) : c("", !0)
  ], 6);
}
const Q = 40, Zl = Q / 2, ei = Math.round(Q * 3.14 * 100) / 100, ti = {
  name: "w-progress",
  props: {
    modelValue: { type: [Number, String, Boolean], default: -1 },
    label: { type: Boolean },
    roundCap: { type: Boolean },
    color: { type: String, default: "primary" },
    bgColor: { type: String },
    labelColor: { type: String },
    size: { type: [Number, String] },
    circle: { type: Boolean },
    stroke: { type: [Number, String], default: 4 },
    shadow: { type: Boolean },
    tile: { type: Boolean },
    round: { type: Boolean },
    outline: { type: Boolean },
    stripes: { type: Boolean },
    absolute: { type: Boolean },
    fixed: { type: Boolean },
    top: { type: Boolean },
    bottom: { type: Boolean },
    zIndex: { type: [Number, String, Boolean] }
  },
  emits: [],
  data: () => ({
    circleSize: Q,
    circleRadius: Zl,
    circleCircumference: ei
  }),
  computed: {
    progressValue() {
      return parseFloat(this.modelValue);
    },
    circleCenter() {
      return Q + this.stroke;
    },
    forcedSize() {
      return this.size && (isNaN(this.size) ? this.size : `${this.size}px`);
    },
    position() {
      return this.top && "top" || this.bottom && "bottom" || "top";
    },
    classes() {
      return {
        [`w-progress--${this.circle ? "circular" : "linear"}`]: !0,
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor && !this.circle,
        [`w-progress--${this.position}`]: !this.circle && (this.absolute || this.fixed),
        "w-progress--default-bg": !this.bgColor,
        "w-progress--indeterminate": this.modelValue === -1,
        "w-progress--outline": !this.circle && this.outline,
        "w-progress--tile": !this.circle && this.tile,
        "w-progress--stripes": !this.circle && this.stripes,
        "w-progress--round": !this.circle && this.round,
        "w-progress--shadow": this.shadow,
        "w-progress--absolute": !this.circle && this.absolute,
        "w-progress--fixed": !this.circle && !this.absolute && this.fixed,
        [`w-progress--${this.roundCap ? "round" : "flat"}-cap`]: !0
      };
    },
    styles() {
      return {
        [this.circle ? "width" : "height"]: this.forcedSize || null
      };
    }
  }
}, li = /* @__PURE__ */ v(ti, [["render", Ql]]), ii = ["id", "name", "checked", "disabled", "required", "tabindex", "aria-checked"], si = ["for"], ai = ["for", "innerHTML"], oi = ["for"], ni = ["for", "innerHTML"];
function ri(e, t, l, a, o, i) {
  return s(), g(V(e.formRegister && !i.wRadios ? "w-form-element" : "div"), B({ ref: "formEl" }, e.formRegister && { validators: e.validators, inputValue: e.inputValue, disabled: e.isDisabled }, {
    valid: e.valid,
    "onUpdate:valid": t[3] || (t[3] = (n) => e.valid = n),
    onReset: t[4] || (t[4] = (n) => {
      e.$emit("update:modelValue", e.inputValue = null), e.$emit("input", null);
    }),
    class: i.classes
  }), {
    default: m(() => [
      w("input", {
        ref: "input",
        id: `w-radio--${e._.uid}`,
        type: "radio",
        name: e.inputName,
        checked: e.inputValue || null,
        disabled: e.isDisabled || null,
        required: e.required || null,
        tabindex: e.tabindex || null,
        onFocus: t[0] || (t[0] = (n) => e.$emit("focus", n)),
        onChange: t[1] || (t[1] = (n) => i.onInput(n)),
        "aria-checked": e.inputValue || "false",
        role: "radio"
      }, null, 40, ii),
      i.hasLabel && l.labelOnLeft ? (s(), u(_, { key: 0 }, [
        e.$slots.default ? (s(), u("label", {
          key: 0,
          class: f(["w-radio__label w-form-el-shakable pr2", e.labelClasses]),
          for: `w-radio--${e._.uid}`
        }, [
          p(e.$slots, "default", {}, () => [
            C(k(l.label), 1)
          ])
        ], 10, si)) : l.label ? (s(), u("label", {
          key: 1,
          class: f(["w-radio__label w-form-el-shakable pr2", e.labelClasses]),
          for: `w-radio--${e._.uid}`,
          innerHTML: l.label
        }, null, 10, ai)) : c("", !0)
      ], 64)) : c("", !0),
      w("div", {
        class: f(["w-radio__input", this.color]),
        onClick: t[2] || (t[2] = (n) => {
          e.$refs.input.focus(), e.$refs.input.click();
        })
      }, null, 2),
      i.hasLabel && !l.labelOnLeft ? (s(), u(_, { key: 1 }, [
        e.$slots.default ? (s(), u("label", {
          key: 0,
          class: f(["w-radio__label w-form-el-shakable pl2", e.labelClasses]),
          for: `w-radio--${e._.uid}`
        }, [
          p(e.$slots, "default", {}, () => [
            C(k(l.label), 1)
          ])
        ], 10, oi)) : l.label ? (s(), u("label", {
          key: 1,
          class: f(["w-radio__label w-form-el-shakable pl2", e.labelClasses]),
          for: `w-radio--${e._.uid}`,
          innerHTML: l.label
        }, null, 10, ni)) : c("", !0)
      ], 64)) : c("", !0)
    ]),
    _: 3
  }, 16, ["valid", "class"]);
}
const di = {
  name: "w-radio",
  mixins: [z],
  inject: { wRadios: { default: null } },
  props: {
    modelValue: { default: !1 },
    returnValue: {},
    label: { type: String },
    labelOnLeft: { type: Boolean },
    color: { type: String, default: "primary" },
    labelColor: { type: String, default: "primary" },
    noRipple: { type: Boolean },
    dark: { type: Boolean },
    light: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "focus"],
  data: () => ({
    inputValue: !1,
    ripple: {
      start: !1,
      end: !1,
      timeout: null
    }
  }),
  computed: {
    hasLabel() {
      return this.label || this.$slots.default;
    },
    classes() {
      return {
        [`w-radio w-radio--${this.inputValue ? "checked" : "unchecked"}`]: !0,
        "w-radio--disabled": this.isDisabled,
        "w-radio--ripple": this.ripple.start,
        "w-radio--rippled": this.ripple.end,
        "w-radio--dark": this.ripple.dark,
        "w-radio--light": this.ripple.light
      };
    }
  },
  methods: {
    toggleFromOutside() {
      this.inputValue = this.returnValue !== void 0 ? this.returnValue === this.modelValue : this.modelValue;
    },
    onInput(e) {
      this.inputValue = e.target.checked;
      const t = this.inputValue && this.returnValue !== void 0 ? this.returnValue : this.inputValue;
      this.$emit("update:modelValue", t), this.$emit("input", t), this.noRipple || (this.inputValue ? (this.ripple.start = !0, this.ripple.timeout = setTimeout(() => {
        this.ripple.start = !1, this.ripple.end = !0, setTimeout(() => this.ripple.end = !1, 100);
      }, 700)) : (this.ripple.start = !1, clearTimeout(this.ripple.timeout)));
    }
  },
  created() {
    this.modelValue !== void 0 && this.toggleFromOutside();
  },
  watch: {
    modelValue() {
      this.toggleFromOutside();
    }
  }
}, ui = /* @__PURE__ */ v(di, [["render", ri]]), hi = ["innerHTML"];
function ci(e, t, l, a, o, i) {
  const n = $("w-radio");
  return s(), g(V(e.formRegister ? "w-form-element" : "div"), B({ ref: "formEl" }, e.formRegister && { validators: e.validators, inputValue: e.inputValue, disabled: e.isDisabled }, {
    valid: e.valid,
    "onUpdate:valid": t[1] || (t[1] = (r) => e.valid = r),
    onReset: t[2] || (t[2] = (r) => {
      e.$emit("update:modelValue", e.inputValue = null), e.$emit("input", null);
    }),
    column: !l.inline,
    wrap: l.inline,
    class: i.classes
  }), {
    default: m(() => [
      (s(!0), u(_, null, T(i.radioItems, (r, d) => (s(), g(n, B({
        key: d,
        "model-value": r.value === l.modelValue,
        "onUpdate:modelValue": (h) => i.onInput(r),
        onFocus: t[0] || (t[0] = (h) => e.$emit("focus", h)),
        name: e.inputName
      }, { label: r.label, color: r.color, labelOnLeft: l.labelOnLeft, labelColor: l.labelColor }, {
        disabled: e.isDisabled || null,
        readonly: e.isReadonly || null,
        class: { mt1: !l.inline && d }
      }), {
        default: m(() => [
          e.$slots[`item.${d + 1}`] || e.$slots.item ? p(e.$slots, e.$slots[`item.${d + 1}`] ? `item.${d + 1}` : "item", {
            key: 0,
            item: i.getOriginalItem(r),
            index: d + 1,
            checked: r.value === l.modelValue,
            innerHTML: r.label
          }) : r.label ? (s(), u("div", {
            key: 1,
            innerHTML: r.label
          }, null, 8, hi)) : c("", !0)
        ]),
        _: 2
      }, 1040, ["model-value", "onUpdate:modelValue", "name", "disabled", "readonly", "class"]))), 128))
    ]),
    _: 3
  }, 16, ["valid", "column", "wrap", "class"]);
}
const pi = {
  name: "w-radios",
  mixins: [z],
  props: {
    items: { type: Array, required: !0 },
    modelValue: { type: [String, Number, Boolean] },
    labelOnLeft: { type: Boolean },
    itemLabelKey: { type: String, default: "label" },
    itemValueKey: { type: String, default: "value" },
    itemColorKey: { type: String, default: "color" },
    inline: { type: Boolean },
    color: { type: String, default: "primary" },
    labelColor: { type: String, default: "primary" }
  },
  emits: ["input", "update:modelValue", "focus"],
  provide() {
    return { wRadios: !0 };
  },
  data: () => ({
    inputValue: null
  }),
  computed: {
    radioItems() {
      return (this.items || []).map((e, t) => ({
        ...e,
        _index: t,
        label: e[this.itemLabelKey],
        value: e[this.itemValueKey] === void 0 ? e[this.itemLabelKey] || t : e[this.itemValueKey],
        color: e[this.itemColorKey] || this.color
      }));
    },
    classes() {
      return [
        "w-radios",
        `w-radios--${this.inline ? "inline" : "column"}`
      ];
    }
  },
  methods: {
    onInput(e) {
      this.inputValue = !0, this.$emit("update:modelValue", e.value), this.$emit("input", e.value);
    },
    getOriginalItem(e) {
      return this.items[e._index];
    }
  }
}, fi = /* @__PURE__ */ v(pi, [["render", ci]]), mi = ["id", "name", "value"], gi = ["disabled", "onMouseenter", "onClick", "tabindex"];
function bi(e, t, l, a, o, i) {
  return s(), g(V(e.formRegister ? "w-form-element" : "div"), B({ ref: "formEl" }, e.formRegister && { validators: e.validators, inputValue: o.rating, disabled: e.isDisabled, readonly: e.isReadonly }, {
    valid: e.valid,
    "onUpdate:valid": t[4] || (t[4] = (n) => e.valid = n),
    onReset: t[5] || (t[5] = (n) => {
      e.$emit("update:modelValue", o.rating = null), e.$emit("input", null);
    }),
    class: i.classes
  }), {
    default: m(() => [
      w("input", {
        id: e.inputName,
        name: e.inputName,
        type: "hidden",
        value: o.rating
      }, null, 8, mi),
      (s(!0), u(_, null, T(l.max, (n) => (s(), u(_, { key: n }, [
        e.$slots.item ? p(e.$slots, "item", {
          key: 0,
          index: n + 1
        }) : c("", !0),
        w("button", {
          class: f(["w-rating__button", i.buttonClasses(n)]),
          disabled: e.isDisabled || e.isReadonly,
          onMouseenter: (r) => o.hover = n,
          onMouseleave: t[0] || (t[0] = (r) => o.hover = 0),
          onClick: (r) => i.onButtonClick(n),
          onFocus: t[1] || (t[1] = (...r) => i.onFocus && i.onFocus(...r)),
          onBlur: t[2] || (t[2] = (...r) => i.onBlur && i.onBlur(...r)),
          onKeydown: t[3] || (t[3] = (...r) => i.onKeydown && i.onKeydown(...r)),
          type: "button",
          tabindex: n === 1 ? 0 : -1
        }, [
          n - 1 === ~~o.rating && o.rating - ~~o.rating ? (s(), u("i", {
            key: 0,
            class: f(["w-icon", `${l.icon} ${l.color}`]),
            role: "icon",
            "aria-hidden": "true",
            style: L(i.halfStarStyle)
          }, null, 6)) : c("", !0)
        ], 42, gi)
      ], 64))), 128))
    ]),
    _: 3
  }, 16, ["valid", "class"]);
}
const yi = {
  name: "w-rating",
  mixins: [z],
  props: {
    modelValue: {},
    max: { type: [Number, String], default: 5 },
    color: { type: String, default: "primary" },
    bgColor: { type: String },
    icon: { type: String, default: "wi-star" },
    xs: { type: Boolean },
    sm: { type: Boolean },
    md: { type: Boolean },
    lg: { type: Boolean },
    xl: { type: Boolean },
    noRipple: { type: Boolean },
    dark: { type: Boolean },
    light: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "focus", "blur"],
  data() {
    return {
      rating: parseFloat(this.modelValue || 0),
      hover: 0,
      hasFocus: 0,
      ripple: {
        start: !1,
        end: !1,
        timeout: null
      }
    };
  },
  computed: {
    size() {
      return this.xs && "xs" || this.sm && "sm" || this.lg && "lg" || this.xl && "xl" || "md";
    },
    classes() {
      return {
        "w-rating": !0,
        "w-rating--dark": this.dark,
        "w-rating--light": this.light,
        "w-rating--focus": this.hasFocus,
        "w-rating--hover": this.hover,
        "w-rating--disabled": this.isDisabled,
        "w-rating--readonly": this.isReadonly,
        "w-rating--ripple": this.ripple.start,
        "w-rating--rippled": this.ripple.end
      };
    },
    halfStarStyle() {
      return {
        width: this.hover <= ~~this.rating && `${(this.rating - ~~this.rating) * 100}%`
      };
    }
  },
  methods: {
    onButtonClick(e) {
      this.rating = e, this.$emit("update:modelValue", this.rating), this.$emit("input", this.rating), this.noRipple || (this.ripple.start = !0, this.ripple.timeout = setTimeout(() => {
        this.ripple.start = !1, this.ripple.end = !0, setTimeout(() => this.ripple.end = !1, 100);
      }, 700));
    },
    onFocus(e) {
      this.hasFocus = !0, this.$emit("focus", e);
    },
    onBlur(e) {
      this.hasFocus = !1, this.$emit("blur", e);
    },
    onKeydown(e) {
      if ([37, 38, 39, 40].includes(e.keyCode)) {
        [39, 40].includes(e.keyCode) ? this.rating <= this.max - 1 && this.rating++ : this.rating > 1 && this.rating--;
        const t = this.$el.querySelectorAll("button")[this.rating - 1];
        t && (t.focus(), t.click()), e.preventDefault();
      }
    },
    buttonClasses(e) {
      const t = e - 1 === ~~this.rating && this.rating - ~~this.rating, l = this.hover >= e || !t && this.hover === 0 && this.rating >= e;
      return {
        "w-rating__button--on": l,
        "w-rating__button--half": t,
        [this.icon]: !0,
        [`size--${this.size}`]: !0,
        [this.color]: l,
        [this.bgColor]: this.bgColor && !l
      };
    }
  },
  watch: {
    value(e) {
      this.rating = parseFloat(e);
    }
  }
}, wi = /* @__PURE__ */ v(yi, [["render", bi]]), vi = { class: "w-scrollbar" };
function ki(e, t, l, a, o, i) {
  return s(), u("div", vi);
}
const _i = {
  name: "w-scrollbar",
  props: {},
  emits: [],
  data: () => ({})
}, Ci = /* @__PURE__ */ v(_i, [["render", ki]]), Bi = ["for"], Si = ["aria-expanded", "aria-owns", "aria-activedescendant"], $i = {
  key: 1,
  class: "w-select__selection-slot"
}, Vi = ["contenteditable", "id", "disabled", "tabindex", "innerHTML"], Ii = ["value", "name"], Ri = ["for"], Li = ["for"];
function Ti(e, t, l, a, o, i) {
  const n = $("w-icon"), r = $("w-list"), d = $("w-menu");
  return s(), g(V(e.formRegister ? "w-form-element" : "div"), B({ ref: "formEl" }, e.formRegister && { validators: e.validators, inputValue: i.selectionString, disabled: e.isDisabled, readonly: e.isReadonly }, {
    valid: e.valid,
    "onUpdate:valid": t[9] || (t[9] = (h) => e.valid = h),
    onReset: i.onReset,
    wrap: i.hasLabel && l.labelPosition !== "inside",
    class: i.classes
  }), {
    default: m(() => [
      l.labelPosition === "left" ? (s(), u(_, { key: 0 }, [
        e.$slots.default || l.label ? (s(), u("label", {
          key: 0,
          class: f(["w-select__label w-select__label--left w-form-el-shakable", e.labelClasses]),
          for: `w-select--${e._.uid}`
        }, [
          p(e.$slots, "default", {}, () => [
            C(k(l.label), 1)
          ])
        ], 10, Bi)) : c("", !0)
      ], 64)) : c("", !0),
      I(d, B({
        modelValue: e.showMenu,
        "onUpdate:modelValue": t[8] || (t[8] = (h) => e.showMenu = h),
        "menu-class": `w-select__menu ${l.menuClass || ""}`,
        transition: "slide-fade-down",
        "append-to": (l.menuProps || {}).appendTo !== void 0 ? (l.menuProps || {}).appendTo : void 0,
        "align-left": "",
        custom: "",
        "min-width": "activator"
      }, l.menuProps || {}), {
        activator: m(({ on: h }) => [
          w("div", {
            class: f(["w-select__selection-wrap", i.inputWrapClasses]),
            onClick: t[5] || (t[5] = (y) => !e.isDisabled && !e.isReadonly && (e.showMenu ? i.closeMenu : i.openMenu)()),
            role: "button",
            "aria-haspopup": "listbox",
            "aria-expanded": e.showMenu ? "true" : "false",
            "aria-owns": `w-select-menu--${e._.uid}`,
            "aria-activedescendant": `w-select-menu--${e._.uid}_item-1`
          }, [
            l.innerIconLeft ? (s(), g(n, {
              key: 0,
              class: "w-select__icon w-select__icon--inner-left",
              tag: "label",
              onClick: t[0] || (t[0] = (y) => e.$emit("click:inner-icon-left", y))
            }, {
              default: m(() => [
                C(k(l.innerIconLeft), 1)
              ]),
              _: 1
            })) : c("", !0),
            e.$slots.selection ? (s(), u("div", $i, [
              p(e.$slots, "selection", {
                item: l.multiple ? e.inputValue : e.inputValue[0]
              })
            ])) : c("", !0),
            w("div", {
              class: f(["w-select__selection", { "w-select__selection--placeholder": !e.$slots.selection && !i.selectionString && l.placeholder }]),
              ref: "selection-input",
              contenteditable: e.isDisabled || e.isReadonly ? "false" : "true",
              onFocus: t[1] || (t[1] = (y) => !e.isDisabled && !e.isReadonly && i.onFocus(y)),
              onBlur: t[2] || (t[2] = (...y) => i.onBlur && i.onBlur(...y)),
              onKeydown: t[3] || (t[3] = (y) => !e.isDisabled && !e.isReadonly && i.onKeydown(y)),
              id: `w-select--${e._.uid}`,
              disabled: e.isDisabled || null,
              readonly: "",
              "aria-readonly": "true",
              tabindex: e.tabindex || null,
              innerHTML: e.$slots.selection ? "" : i.selectionString || l.placeholder
            }, null, 42, Vi),
            (s(!0), u(_, null, T(e.inputValue.length ? e.inputValue : [{}], (y, S) => (s(), u("input", {
              key: S,
              type: "hidden",
              value: y.value === void 0 ? "" : y.value.toString(),
              name: e.inputName + (l.multiple ? "[]" : "")
            }, null, 8, Ii))), 128)),
            l.labelPosition === "inside" && i.showLabelInside ? (s(), u(_, { key: 2 }, [
              e.$slots.default || l.label ? (s(), u("label", {
                key: 0,
                class: f(["w-select__label w-select__label--inside w-form-el-shakable", e.labelClasses]),
                for: `w-select--${e._.uid}`
              }, [
                p(e.$slots, "default", {}, () => [
                  C(k(l.label), 1)
                ])
              ], 10, Ri)) : c("", !0)
            ], 64)) : c("", !0),
            l.innerIconRight ? (s(), g(n, {
              key: 3,
              class: "w-select__icon w-select__icon--inner-right",
              tag: "label",
              onClick: t[4] || (t[4] = (y) => e.$emit("click:inner-icon-right", y))
            }, {
              default: m(() => [
                C(k(l.innerIconRight), 1)
              ]),
              _: 1
            })) : c("", !0)
          ], 10, Si)
        ]),
        default: m(() => [
          I(r, {
            ref: "w-list",
            "model-value": e.inputValue,
            "onUpdate:modelValue": i.onInput,
            onItemClick: t[6] || (t[6] = (h) => e.$emit("item-click", h)),
            onItemSelect: i.onListItemSelect,
            "onKeydown:enter": t[7] || (t[7] = (h) => l.noUnselect && !l.multiple && i.closeMenu()),
            "onKeydown:escape": i.closeMenu,
            items: i.selectItems,
            multiple: l.multiple,
            "arrows-navigation": "",
            "return-object": "",
            "add-ids": `w-select-menu--${e._.uid}`,
            "no-unselect": l.noUnselect,
            "selection-color": l.selectionColor,
            "item-color-key": l.itemColorKey,
            role: "listbox",
            tabindex: "-1"
          }, Z({ _: 2 }, [
            T(l.items.length, (h) => ({
              name: `item.${h}`,
              fn: m(({ item: y, selected: S, index: b }) => [
                e.$slots[`item.${h}`] && e.$slots[`item.${h}`](y, S, b) ? p(e.$slots, `item.${h}`, {
                  key: 0,
                  item: y,
                  selected: S,
                  index: b
                }, () => [
                  C(k(y[l.itemLabelKey]), 1)
                ]) : p(e.$slots, "item", {
                  key: 1,
                  item: y,
                  selected: S,
                  index: b
                }, () => [
                  C(k(y[l.itemLabelKey]), 1)
                ])
              ])
            }))
          ]), 1032, ["model-value", "onUpdate:modelValue", "onItemSelect", "onKeydown:escape", "items", "multiple", "add-ids", "no-unselect", "selection-color", "item-color-key"])
        ]),
        _: 3
      }, 16, ["modelValue", "menu-class", "append-to"]),
      l.labelPosition === "right" ? (s(), u(_, { key: 1 }, [
        e.$slots.default || l.label ? (s(), u("label", {
          key: 0,
          class: f(["w-select__label w-select__label--right w-form-el-shakable", e.labelClasses]),
          for: `w-select--${e._.uid}`
        }, [
          p(e.$slots, "default", {}, () => [
            C(k(l.label), 1)
          ])
        ], 10, Li)) : c("", !0)
      ], 64)) : c("", !0)
    ]),
    _: 3
  }, 16, ["valid", "onReset", "wrap", "class"]);
}
const xi = {
  name: "w-select",
  mixins: [z],
  props: {
    items: { type: Array, required: !0 },
    modelValue: {},
    multiple: { type: Boolean },
    placeholder: { type: String },
    label: { type: String },
    labelPosition: { type: String, default: "inside" },
    innerIconLeft: { type: String },
    innerIconRight: { type: String, default: "wi-triangle-down" },
    staticLabel: { type: Boolean },
    itemLabelKey: { type: String, default: "label" },
    itemColorKey: { type: String, default: "color" },
    itemValueKey: { type: String, default: "value" },
    itemClass: { type: String },
    menuClass: { type: String },
    color: { type: String, default: "primary" },
    bgColor: { type: String },
    labelColor: { type: String, default: "primary" },
    selectionColor: { type: String, default: "primary" },
    outline: { type: Boolean },
    round: { type: Boolean },
    shadow: { type: Boolean },
    tile: { type: Boolean },
    returnObject: { type: Boolean },
    noUnselect: { type: Boolean },
    menuProps: { type: Object },
    dark: { type: Boolean },
    light: { type: Boolean },
    fitToContent: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "focus", "blur", "item-click", "item-select", "click:inner-icon-left", "click:inner-icon-right"],
  data: () => ({
    inputValue: [],
    showMenu: !1,
    menuMinWidth: 0,
    isFocused: !1,
    selectionWrapRef: void 0
  }),
  computed: {
    selectItems() {
      return this.items.map((e, t) => {
        const l = { ...e };
        return l.value = l[this.itemValueKey] === void 0 ? l[this.itemLabelKey] || t : l[this.itemValueKey], l.index = t, l;
      });
    },
    hasValue() {
      return Array.isArray(this.inputValue) ? this.inputValue.length : this.inputValue !== null;
    },
    hasLabel() {
      return this.label || this.$slots.default;
    },
    showLabelInside() {
      return !this.staticLabel || !this.hasValue && !this.placeholder;
    },
    selectionString() {
      return this.inputValue && this.inputValue.map(
        (e) => e[this.itemValueKey] !== void 0 ? e[this.itemLabelKey] : e[this.itemLabelKey] !== void 0 ? e[this.itemLabelKey] : e
      ).join(", ");
    },
    classes() {
      return {
        "w-select": !0,
        "w-select--dark": this.dark,
        "w-select--light": this.light,
        "w-select--disabled": this.isDisabled,
        "w-select--fit-to-content": this.fitToContent,
        "w-select--readonly": this.isReadonly,
        [`w-select--${this.hasValue ? "filled" : "empty"}`]: !0,
        "w-select--focused": (this.isFocused || this.showMenu) && !this.isReadonly,
        "w-select--floating-label": this.hasLabel && this.labelPosition === "inside" && !this.staticLabel,
        "w-select--no-padding": !this.outline && !this.bgColor && !this.shadow && !this.round,
        "w-select--has-placeholder": this.placeholder,
        "w-select--inner-icon-left": this.innerIconLeft,
        "w-select--inner-icon-right": this.innerIconRight,
        "w-select--open": this.showMenu
      };
    },
    inputWrapClasses() {
      return {
        [this.valid === !1 ? "error" : this.color]: this.color || this.valid === !1,
        [`${this.bgColor}--bg`]: this.bgColor,
        "w-select__selection-wrap--round": this.round,
        "w-select__selection-wrap--tile": this.tile,
        "w-select__selection-wrap--box": this.outline || this.bgColor || this.shadow,
        "w-select__selection-wrap--underline": !this.outline,
        "w-select__selection-wrap--shadow": this.shadow,
        "w-select__selection-wrap--no-padding": !this.outline && !this.bgColor && !this.shadow && !this.round
      };
    }
  },
  methods: {
    onFocus(e) {
      return this.isFocused = !0, this.$emit("focus", e), !1;
    },
    onBlur(e) {
      this.isFocused = !1, this.$emit("blur", e);
    },
    onKeydown(e) {
      if (e.preventDefault(), [13, 27, 38, 40].includes(e.keyCode) && e.preventDefault(), e.keyCode === 27)
        this.closeMenu();
      else if (e.keyCode === 13)
        this.openMenu();
      else if ([38, 40].includes(e.keyCode))
        if (this.multiple)
          this.openMenu();
        else {
          let { index: t } = this.inputValue[0] || {};
          const l = this.selectItems;
          if (t === void 0)
            t = e.keyCode === 38 ? l.length - 1 : 0;
          else {
            const a = e.keyCode === 38 ? -1 : 1;
            t = (t + l.length + a) % l.length;
          }
          this.onInput(l[t]);
        }
    },
    onInput(e) {
      this.inputValue = e === null ? [] : this.multiple ? e : [e], e = this.inputValue.map((l) => this.returnObject ? this.items[l.index] : l.value);
      const t = this.multiple ? e : e[0];
      this.$emit("update:modelValue", t), this.$emit("input", t);
    },
    onListItemSelect(e) {
      this.$emit("item-select", e), this.multiple || this.closeMenu();
    },
    onReset() {
      this.inputValue = [];
      const e = this.multiple ? [] : null;
      this.$emit("update:modelValue", e), this.$emit("input", e);
    },
    checkSelection(e) {
      e = Array.isArray(e) ? e : e !== void 0 ? [e] : [];
      const t = this.selectItems.map((l) => l.value);
      return e.map((l) => {
        let a = l;
        return typeof l == "object" && (a = l[this.itemValueKey] !== void 0 ? l[this.itemValueKey] : l[this.itemLabelKey] !== void 0 ? l[this.itemLabelKey] : l), this.selectItems[t.indexOf(a)];
      }).filter((l) => l !== void 0);
    },
    openMenu() {
      this.showMenu = !0, setTimeout(() => {
        var t;
        const e = this.inputValue.length ? this.inputValue[0].index : 0;
        (t = this.$refs["w-list"].$el.querySelector(`#w-select-menu--${this._.uid}_item-${e + 1}`)) == null || t.focus();
      }, 100);
    },
    closeMenu() {
      (this.menuProps || {}).hideOnMenuClick !== !1 && (this.showMenu = !1, setTimeout(() => this.$refs["selection-input"].focus(), 50));
    }
  },
  created() {
    this.inputValue = this.checkSelection(this.modelValue);
  },
  watch: {
    modelValue(e) {
      e !== this.inputValue && (this.inputValue = this.checkSelection(e));
    },
    items() {
      this.inputValue = this.checkSelection(this.modelValue);
    }
  }
}, Pi = /* @__PURE__ */ v(xi, [["render", Ti]]), Oi = ["for"], zi = ["for", "innerHTML"], Ei = { class: "w-slider__track-wrap" }, Mi = ["aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-readonly"], Ni = ["id", "name", "model-value", "disabled", "readonly", "aria-readonly", "tabindex"], Wi = ["for"], Ai = { key: 0 }, Ki = {
  key: 0,
  class: "w-slider__step-labels"
}, Di = ["onClick"], Fi = ["for"], Hi = ["for", "innerHTML"];
function ji(e, t, l, a, o, i) {
  return s(), g(V(e.formRegister ? "w-form-element" : "div"), B({ ref: "formEl" }, e.formRegister && { validators: e.validators, inputValue: e.rangeValueScaled, disabled: e.isDisabled, readonly: e.isReadonly }, {
    valid: e.valid,
    "onUpdate:valid": t[8] || (t[8] = (n) => e.valid = n),
    onReset: t[9] || (t[9] = (n) => {
      e.rangeValuePercent = 0, i.updateRangeValueScaled();
    }),
    wrap: e.formRegister || null,
    class: i.wrapperClasses
  }), {
    default: m(() => [
      e.$slots["label-left"] ? (s(), u("label", {
        key: 0,
        class: f(["w-slider__label w-slider__label--left w-form-el-shakable", e.labelClasses]),
        for: `button--${e._.uid}`
      }, [
        p(e.$slots, "label-left")
      ], 10, Oi)) : l.labelLeft ? (s(), u("label", {
        key: 1,
        class: f(["w-slider__label w-slider__label--left w-form-el-shakable", e.labelClasses]),
        for: `button--${e._.uid}`,
        innerHTML: l.labelLeft
      }, null, 10, zi)) : c("", !0),
      w("div", Ei, [
        w("div", {
          class: f(["w-slider__track", i.trackClasses]),
          ref: "track",
          onMousedown: t[4] || (t[4] = (...n) => i.onTrackMouseDown && i.onTrackMouseDown(...n)),
          onTouchstart: t[5] || (t[5] = (...n) => i.onTrackMouseDown && i.onTrackMouseDown(...n)),
          role: "slider",
          "aria-label": "Slider",
          "aria-valuemin": i.minVal,
          "aria-valuemax": i.maxVal,
          "aria-valuenow": e.rangeValueScaled,
          "aria-readonly": e.isReadonly ? "true" : "false",
          "aria-orientation": "horizontal"
        }, [
          w("div", {
            class: f(["w-slider__range", i.rangeClasses]),
            style: L(i.rangeStyles)
          }, null, 6),
          w("div", {
            class: "w-slider__thumb",
            style: L(i.thumbStyles)
          }, [
            w("button", {
              class: f(["w-slider__thumb-button", [l.color]]),
              ref: "thumb",
              id: `button--${e._.uid}`,
              name: e.inputName,
              "model-value": e.rangeValueScaled,
              disabled: e.isDisabled || null,
              readonly: e.isReadonly || null,
              "aria-readonly": e.isReadonly ? "true" : "false",
              tabindex: e.isDisabled || e.isReadonly ? -1 : null,
              onKeydown: [
                t[0] || (t[0] = M((n) => i.onKeyDown(n, -1), ["left"])),
                t[1] || (t[1] = M((n) => i.onKeyDown(n, 1), ["right"]))
              ],
              onFocus: t[2] || (t[2] = (n) => e.$emit("focus", n)),
              onClick: t[3] || (t[3] = E(() => {
              }, ["prevent"]))
            }, null, 42, Ni),
            l.thumbLabel ? (s(), u("label", {
              key: 0,
              class: f(["w-slider__thumb-label", i.thumbClasses]),
              for: `button--${e._.uid}`
            }, [
              l.thumbLabel === "droplet" ? (s(), u("div", Ai, [
                p(e.$slots, "label", { value: e.rangeValueScaled }, () => [
                  C(k(~~e.rangeValueScaled), 1)
                ])
              ])) : p(e.$slots, "label", {
                key: 1,
                value: e.rangeValueScaled
              }, () => [
                C(k(~~e.rangeValueScaled), 1)
              ])
            ], 10, Wi)) : c("", !0)
          ], 4)
        ], 42, Mi),
        l.stepLabels && l.step ? (s(), u("div", Ki, [
          w("div", {
            class: "w-slider__step-label",
            onClick: t[6] || (t[6] = (n) => i.onStepLabelClick(0))
          }, k(this.minVal), 1),
          (s(!0), u(_, null, T(~~i.numberOfSteps, (n) => (s(), u("div", {
            class: "w-slider__step-label",
            key: n,
            onClick: (r) => i.onStepLabelClick(n * (100 / i.numberOfSteps)),
            style: L(`left: ${n * (100 / i.numberOfSteps)}%`)
          }, k(i.percentToScaled(n * (100 / i.numberOfSteps))), 13, Di))), 128)),
          ~~i.numberOfSteps !== i.numberOfSteps ? (s(), u("div", {
            key: 0,
            class: "w-slider__step-label",
            onClick: t[7] || (t[7] = (n) => i.onStepLabelClick(100)),
            style: { left: "100%" }
          }, k(this.maxVal), 1)) : c("", !0)
        ])) : c("", !0)
      ]),
      e.$slots["label-right"] ? (s(), u("label", {
        key: 2,
        class: f(["w-slider__label w-slider__label--right w-form-el-shakable", e.labelClasses]),
        for: `button--${e._.uid}`
      }, [
        p(e.$slots, "label-right")
      ], 10, Fi)) : l.labelRight ? (s(), u("label", {
        key: 3,
        class: f(["w-slider__label w-slider__label--right w-form-el-shakable", e.labelClasses]),
        for: `button--${e._.uid}`,
        innerHTML: l.labelRight
      }, null, 10, Hi)) : c("", !0)
    ]),
    _: 3
  }, 16, ["valid", "wrap", "class"]);
}
const Ui = {
  name: "w-slider",
  mixins: [z],
  props: {
    modelValue: { type: Number, default: 0 },
    color: { type: String, default: "primary" },
    bgColor: { type: String },
    labelColor: { type: String, default: "primary" },
    stepLabels: { type: [Boolean, Array] },
    thumbLabel: { type: [Boolean, String] },
    thumbLabelClass: { type: String },
    trackClass: { type: String },
    rangeClass: { type: String },
    min: { type: [Number, String], default: 0 },
    max: { type: [Number, String], default: 100 },
    step: { type: [Number, String] },
    labelLeft: { type: String },
    labelRight: { type: String },
    dark: { type: Boolean },
    light: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "focus"],
  data: () => ({
    track: {
      el: null,
      left: 0,
      width: 0
    },
    dragging: !1,
    rangeValuePercent: 0,
    rangeValueScaled: 0
  }),
  computed: {
    minVal() {
      return parseFloat(this.min);
    },
    maxVal() {
      return parseFloat(this.max);
    },
    stepValPercent() {
      return Math.min(parseFloat(this.step), this.scaledRange) / this.scaledRange * 100;
    },
    scaledRange() {
      return this.maxVal - this.minVal;
    },
    numberOfSteps() {
      return 100 / this.stepValPercent;
    },
    rangeStyles() {
      return {
        width: `${this.rangeValuePercent}%`
      };
    },
    thumbStyles() {
      return {
        left: `${this.rangeValuePercent}%`
      };
    },
    rangeClasses() {
      return {
        [`${this.color}--bg`]: this.color,
        [this.rangeClass]: this.rangeClass || null
      };
    },
    trackClasses() {
      return {
        [`${this.bgColor}--bg`]: this.bgColor,
        [this.trackClass]: this.trackClass || null
      };
    },
    thumbClasses() {
      return {
        [this.thumbLabelClass]: this.thumbLabelClass || null,
        "w-slider__thumb-label--droplet": this.thumbLabel === "droplet"
      };
    },
    wrapperClasses() {
      return {
        "w-slider": !0,
        "w-slider--dark": this.dark,
        "w-slider--light": this.light,
        "w-slider--dragging": this.dragging,
        "w-slider--disabled": this.isDisabled,
        "w-slider--readonly": this.isReadonly,
        "w-slider--has-step-labels": this.step && this.stepLabels
      };
    }
  },
  methods: {
    scaledToPercent(e) {
      return Math.max(0, Math.min((e - this.minVal) / this.scaledRange * 100, 100));
    },
    percentToScaled(e) {
      return Math.round((e / 100 * this.scaledRange + this.minVal) * 100) / 100;
    },
    onTrackMouseDown(e) {
      if (this.isDisabled || this.isReadonly || "ontouchstart" in window && e.type === "mousedown")
        return;
      const { left: t, width: l } = this.track.el.getBoundingClientRect();
      this.track.width = l, this.track.left = t, this.dragging = !0, this.updateRange(e.type === "touchstart" ? e.touches[0].clientX : e.clientX), document.addEventListener(e.type === "touchstart" ? "touchmove" : "mousemove", this.onDrag), document.addEventListener(e.type === "touchstart" ? "touchend" : "mouseup", this.onMouseUp, { once: !0 });
    },
    onDrag(e) {
      this.updateRange(e.type === "touchmove" ? e.touches[0].clientX : e.clientX);
    },
    onMouseUp(e) {
      this.dragging = !1, document.removeEventListener(e.type === "touchend" ? "touchmove" : "mousemove", this.onDrag), this.$refs.thumb && this.$refs.thumb.focus();
    },
    onStepLabelClick(e) {
      this.rangeValuePercent = e, this.updateRangeValueScaled();
    },
    onKeyDown(e, t) {
      this.isDisabled || this.isReadonly || (this.rangeValuePercent += t * (e.shiftKey ? 5 : 1) * (this.stepValPercent || 1), this.rangeValuePercent = Math.max(0, Math.min(this.rangeValuePercent, 100)), this.updateRangeValueScaled());
    },
    updateRange(e) {
      if (this.rangeValuePercent = Math.max(0, Math.min((e - this.track.left) / this.track.width * 100, 100)), this.step) {
        const t = this.rangeValuePercent + this.stepValPercent / 2;
        this.rangeValuePercent = t - t % this.stepValPercent;
      }
      this.updateRangeValueScaled();
    },
    updateRangeValueScaled() {
      this.rangeValueScaled = this.percentToScaled(this.rangeValuePercent), this.$emit("update:modelValue", this.rangeValueScaled), this.$emit("input", this.rangeValueScaled);
    }
  },
  beforeMount() {
    this.$nextTick(() => {
      this.track.el = this.$refs.track, this.rangeValueScaled = this.modelValue, this.rangeValuePercent = this.scaledToPercent(this.modelValue);
    });
  },
  watch: {
    modelValue(e) {
      this.rangeValueScaled !== e && (this.rangeValueScaled = e, this.rangeValuePercent = this.scaledToPercent(e));
    }
  }
}, qi = /* @__PURE__ */ v(Ui, [["render", ji]]), Gi = { key: 0 };
function Xi(e, t, l, a, o, i) {
  return l.modelValue || l.modelValue === void 0 ? (s(), u("div", {
    key: 0,
    class: f(["w-spinner", i.classes]),
    style: L(i.styles)
  }, [
    i.isThreeDots ? (s(), u("span", Gi)) : c("", !0)
  ], 6)) : c("", !0);
}
const Yi = {
  name: "w-spinner",
  props: {
    modelValue: {},
    color: { type: String, default: "primary" },
    xs: { type: Boolean },
    sm: { type: Boolean },
    md: { type: Boolean },
    lg: { type: Boolean },
    xl: { type: Boolean },
    size: { type: [Number, String] },
    bounce: { type: Boolean },
    fade: { type: Boolean }
  },
  emits: [],
  computed: {
    isThreeDots() {
      return !this.bounce && !this.fade;
    },
    forcedSize() {
      return this.size && (isNaN(this.size) ? this.size : `${this.size}px`);
    },
    presetSize() {
      return this.xs && "xs" || this.sm && "sm" || this.md && "md" || this.lg && "lg" || this.xl && "xl" || null;
    },
    styles() {
      return this.forcedSize && `font-size: ${this.forcedSize}` || null;
    },
    classes() {
      return {
        [this.color]: this.color,
        [`size--${this.presetSize}`]: this.presetSize && !this.forcedSize,
        "w-spinner--bounce": this.bounce,
        "w-spinner--fade": this.fade,
        "w-spinner--three-dots": this.isThreeDots
      };
    }
  }
}, Ji = /* @__PURE__ */ v(Yi, [["render", Xi]]);
function Qi(e, t, l, a, o, i) {
  return s(), u("div", {
    class: f(["w-steps", i.classes])
  }, null, 2);
}
const Zi = {
  name: "w-steps",
  props: {
    dark: { type: Boolean },
    light: { type: Boolean }
  },
  emits: [],
  data: () => ({}),
  computed: {
    classes() {
      return {
        "w-steps--dark": this.dark,
        "w-steps--light": this.light
      };
    }
  }
}, es = /* @__PURE__ */ v(Zi, [["render", Qi]]), ts = ["id", "name", "checked", "disabled", "readonly", "aria-readonly", "required", "tabindex", "aria-checked"], ls = ["for"], is = {
  key: 0,
  class: "w-switch__track"
}, ss = {
  key: 1,
  class: "w-switch__thumb"
}, as = ["for"];
function os(e, t, l, a, o, i) {
  const n = $("w-progress");
  return s(), g(V(e.formRegister ? "w-form-element" : "div"), B({ ref: "formEl" }, e.formRegister && { validators: e.validators, inputValue: o.isOn, disabled: e.isDisabled, readonly: e.isReadonly }, {
    valid: e.valid,
    "onUpdate:valid": t[3] || (t[3] = (r) => e.valid = r),
    onReset: t[4] || (t[4] = (r) => {
      e.$emit("update:modelValue", o.isOn = null), e.$emit("input", null);
    }),
    class: i.classes
  }), {
    default: m(() => [
      w("input", {
        ref: "input",
        id: `w-switch--${e._.uid}`,
        type: "checkbox",
        name: e.inputName,
        checked: o.isOn,
        disabled: e.isDisabled || e.isReadonly || null,
        readonly: e.isReadonly || null,
        "aria-readonly": e.isReadonly ? "true" : "false",
        required: e.required || null,
        tabindex: e.tabindex || null,
        onChange: t[0] || (t[0] = (r) => i.onInput()),
        onFocus: t[1] || (t[1] = (r) => e.$emit("focus", r)),
        "aria-checked": o.isOn || "false",
        role: "switch"
      }, null, 40, ts),
      i.hasLabel && l.labelOnLeft ? (s(), u(_, { key: 0 }, [
        e.$slots.default || l.label ? (s(), u("label", {
          key: 0,
          class: f(["w-switch__label w-switch__label--left w-form-el-shakable", e.labelClasses]),
          for: `w-switch--${e._.uid}`
        }, [
          p(e.$slots, "default", {}, () => [
            C(k(l.label), 1)
          ])
        ], 10, ls)) : c("", !0)
      ], 64)) : c("", !0),
      w("div", B({
        class: "w-switch__input",
        onClick: t[2] || (t[2] = (r) => {
          e.$refs.input.focus(), e.$refs.input.click();
        })
      }, N(e.$attrs, !0), { class: i.inputClasses }), [
        e.$slots.track ? (s(), u("div", is, [
          p(e.$slots, "track")
        ])) : c("", !0),
        e.$slots.thumb || l.loading ? (s(), u("div", ss, [
          l.loading ? (s(), g(n, B({
            key: 0,
            circle: "",
            color: "inherit"
          }, typeof l.loading == "number" && { "model-value": l.loading }), null, 16)) : p(e.$slots, "thumb", { key: 1 })
        ])) : c("", !0)
      ], 16),
      i.hasLabel && !l.labelOnLeft ? (s(), u(_, { key: 1 }, [
        e.$slots.default || l.label ? (s(), u("label", {
          key: 0,
          class: f(["w-switch__label w-switch__label--right w-form-el-shakable", e.labelClasses]),
          for: `w-switch--${e._.uid}`
        }, [
          p(e.$slots, "default", {}, () => [
            C(k(l.label), 1)
          ])
        ], 10, as)) : c("", !0)
      ], 64)) : c("", !0)
    ]),
    _: 3
  }, 16, ["valid", "class"]);
}
const ns = {
  name: "w-switch",
  mixins: [z],
  props: {
    modelValue: { default: !1 },
    label: { type: String, default: "" },
    labelOnLeft: { type: Boolean },
    color: { type: String, default: "primary" },
    labelColor: { type: String, default: "primary" },
    thin: { type: Boolean },
    noRipple: { type: Boolean },
    loading: { type: [Boolean, Number], default: !1 },
    dark: { type: Boolean },
    light: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "focus"],
  data() {
    return {
      isOn: this.modelValue,
      ripple: {
        start: !1,
        end: !1,
        timeout: null
      }
    };
  },
  computed: {
    hasLabel() {
      return this.label || this.$slots.default;
    },
    classes() {
      return {
        [`w-switch w-switch--${this.isOn ? "on" : "off"}`]: !0,
        "w-switch--thin": this.thin,
        "w-switch--disabled": this.isDisabled,
        "w-switch--readonly": this.isReadonly,
        "w-switch--ripple": this.ripple.start,
        "w-switch--custom-thumb": this.$slots.thumb,
        "w-switch--custom-track": this.$slots.track,
        "w-switch--loading": this.loading,
        "w-switch--rippled": this.ripple.end,
        "w-switch--dark": this.dark,
        "w-switch--light": this.light
      };
    },
    inputClasses() {
      const e = this.hasLabel && this.labelOnLeft ? "l" : "r";
      return [
        this.color,
        this.hasLabel ? this.thin ? `m${e}3` : `m${e}2` : ""
      ];
    }
  },
  methods: {
    onInput() {
      this.isOn = !this.isOn, this.$emit("update:modelValue", this.isOn), this.$emit("input", this.isOn), this.noRipple || (this.isOn ? (this.ripple.start = !0, this.ripple.timeout = setTimeout(() => {
        this.ripple.start = !1, this.ripple.end = !0, setTimeout(() => this.ripple.end = !1, 100);
      }, 700)) : (this.ripple.start = !1, clearTimeout(this.ripple.timeout)));
    }
  },
  watch: {
    modelValue(e) {
      this.isOn = e;
    }
  }
}, rs = /* @__PURE__ */ v(ns, [["render", os]]), ds = { class: "w-tabs__content" };
function us(e, t, l, a, o, i) {
  return s(), u("div", ds, [
    p(e.$slots, "default", { item: l.item })
  ]);
}
const hs = {
  props: { item: Object }
}, cs = /* @__PURE__ */ v(hs, [["render", us]]), ps = ["onClick", "onFocus", "tabindex", "onKeypress", "aria-selected"], fs = ["innerHTML"], ms = {
  key: 0,
  class: "w-tabs__bar-extra"
}, gs = {
  key: 0,
  class: "w-tabs__content-wrap"
}, bs = ["innerHTML"];
function ys(e, t, l, a, o, i) {
  const n = $("tab-content");
  return s(), u("div", {
    class: f(["w-tabs", i.tabsClasses])
  }, [
    w("div", {
      class: f(["w-tabs__bar", i.tabsBarClasses]),
      ref: "tabs-bar"
    }, [
      (s(!0), u(_, null, T(i.tabsItems, (r, d) => (s(), u("div", {
        class: f(["w-tabs__bar-item", i.barItemClasses(r)]),
        key: d,
        onClick: (h) => !r._disabled && i.openTab(r),
        onFocus: (h) => e.$emit("focus", i.getOriginalItem(r)),
        tabindex: !r._disabled && 0,
        onKeypress: M((h) => !r._disabled && i.openTab(r), ["enter"]),
        "aria-selected": r._index === e.activeTabIndex ? "true" : "false",
        role: "tab"
      }, [
        e.$slots[`item-title.${r.id || d + 1}`] ? p(e.$slots, `item-title.${r.id || d + 1}`, {
          key: 0,
          item: i.getOriginalItem(r),
          index: d + 1,
          active: r._index === e.activeTabIndex
        }) : p(e.$slots, "item-title", {
          key: 1,
          item: i.getOriginalItem(r),
          index: d + 1,
          active: r._index === e.activeTabIndex
        }, () => [
          w("div", {
            innerHTML: r[l.itemTitleKey]
          }, null, 8, fs)
        ])
      ], 42, ps))), 128)),
      e.$slots["tabs-bar-extra"] ? (s(), u("div", ms, [
        p(e.$slots, "tabs-bar-extra")
      ])) : c("", !0),
      !l.noSlider && !l.card ? (s(), u("div", {
        key: 1,
        class: f(["w-tabs__slider", l.sliderColor]),
        style: L(i.sliderStyles)
      }, null, 6)) : c("", !0)
    ], 2),
    i.tabsItems.length ? (s(), u("div", gs, [
      I(x, {
        name: i.transitionName,
        mode: i.transitionMode
      }, {
        default: m(() => [
          (s(), g($e, null, [
            (s(), g(n, {
              key: i.activeTab._index,
              item: i.activeTab,
              class: f(l.contentClass)
            }, {
              default: m(({ item: r }) => [
                e.$slots[`item-content.${r._index + 1}`] ? p(e.$slots, `item-content.${r._index + 1}`, {
                  key: 0,
                  item: i.getOriginalItem(r),
                  index: r._index + 1,
                  active: r._index === i.activeTab._index
                }) : p(e.$slots, "item-content", {
                  key: 1,
                  item: i.getOriginalItem(r),
                  index: r._index + 1,
                  active: r._index === i.activeTab._index
                }, () => [
                  r[l.itemContentKey] ? (s(), u("div", {
                    key: 0,
                    innerHTML: r[l.itemContentKey]
                  }, null, 8, bs)) : c("", !0)
                ])
              ]),
              _: 3
            }, 8, ["item", "class"]))
          ], 1024))
        ]),
        _: 3
      }, 8, ["name", "mode"])
    ])) : c("", !0)
  ], 2);
}
const ws = {
  name: "w-tabs",
  props: {
    modelValue: { type: [Number, String] },
    color: { type: String },
    bgColor: { type: String },
    items: { type: [Array, Number] },
    itemTitleKey: { type: String, default: "title" },
    itemContentKey: { type: String, default: "content" },
    titleClass: { type: String },
    activeClass: { type: String, default: "primary" },
    noSlider: { type: Boolean },
    pillSlider: { type: Boolean },
    sliderColor: { type: String, default: "primary" },
    contentClass: { type: String },
    transition: { type: [String, Boolean], default: "" },
    fillBar: { type: Boolean },
    center: { type: Boolean },
    right: { type: Boolean },
    card: { type: Boolean },
    dark: { type: Boolean },
    light: { type: Boolean }
  },
  components: { TabContent: cs },
  emits: ["input", "update:modelValue", "focus"],
  data: () => ({
    activeTabEl: null,
    activeTabIndex: 0,
    prevTabIndex: -1,
    slider: {
      left: 0,
      width: 0
    },
    init: !0
  }),
  computed: {
    transitionName() {
      return this.transition === !1 ? "" : this.transition || `w-tabs-slide-${this.direction}`;
    },
    transitionMode() {
      return ["w-tabs-slide-left", "w-tabs-slide-right"].includes(this.transitionName) ? "" : "out-in";
    },
    direction() {
      return this.activeTab._index < this.prevTabIndex ? "right" : "left";
    },
    tabsItems() {
      return (typeof this.items == "number" ? Array(this.items).fill({}) : this.items).map((t, l) => G({
        ...t,
        _index: l,
        _disabled: !!t.disabled
      }));
    },
    activeTab() {
      return this.tabsItems[this.activeTabIndex] || this.tabsItems[0] || {};
    },
    tabsClasses() {
      return {
        "w-tabs--card": this.card,
        "w-tabs--no-slider": this.noSlider,
        "w-tabs--pill-slider": this.pillSlider,
        "w-tabs--fill-bar": this.fillBar,
        "w-tabs--init": this.init,
        "w-tabs--dark": this.dark,
        "w-tabs--light": this.light
      };
    },
    tabsBarClasses() {
      return {
        "w-tabs__bar--right": this.right,
        "w-tabs__bar--center": this.center
      };
    },
    sliderStyles() {
      return {
        left: this.slider.left,
        width: this.slider.width
      };
    }
  },
  methods: {
    onResize() {
      this.updateSlider(!1);
    },
    barItemClasses(e) {
      const t = e._index === this.activeTabIndex;
      return {
        [`${this.bgColor}--bg`]: this.bgColor,
        [this.color]: this.color && !e._disabled && !(this.activeClass && t),
        [`w-tabs__bar-item--active ${this.activeClass}`]: t,
        "w-tabs__bar-item--disabled": e._disabled,
        [this.titleClass]: this.titleClass
      };
    },
    openTab(e) {
      this.prevTabIndex = this.activeTabIndex, this.activeTabIndex = e._index, this.$emit("update:modelValue", e._index), this.$emit("input", e._index), this.noSlider || this.$nextTick(this.updateSlider);
    },
    updateSlider(e = !0) {
      if (e) {
        const t = this.$refs["tabs-bar"];
        this.activeTabEl = t && t.querySelector(".w-tabs__bar-item--active");
      }
      if (!this.fillBar && this.activeTabEl) {
        const { left: t, width: l } = this.activeTabEl.getBoundingClientRect(), a = this.activeTabEl.parentNode, { left: o } = a.getBoundingClientRect(), { borderLeftWidth: i } = getComputedStyle(a);
        this.slider.left = `${t - o - parseInt(i) + a.scrollLeft}px`, this.slider.width = `${l}px`;
      } else
        this.slider.left = `${this.activeTab._index * 100 / this.tabsItems.length}%`, this.slider.width = `${100 / this.tabsItems.length}%`;
    },
    updateActiveTab(e) {
      typeof e == "string" ? e = ~~e : (isNaN(e) || e < 0) && (e = 0), this.activeTabIndex = e, this.$nextTick(() => {
        const t = this.$refs["tabs-bar"];
        this.activeTabEl = t && t.querySelector(`.w-tabs__bar-item:nth-child(${e + 1})`), this.activeTabEl && this.activeTabEl.scrollIntoView({ behavior: "smooth", block: "nearest", inline: "nearest" });
      });
    },
    getOriginalItem(e) {
      return this.items[e._index];
    }
  },
  beforeMount() {
    this.updateActiveTab(this.modelValue), this.$nextTick(() => {
      this.updateSlider(), setTimeout(() => this.init = !1, 0);
    }), this.noSlider || window.addEventListener("resize", this.onResize);
  },
  beforeUnmount() {
    window.removeEventListener("resize", this.onResize);
  },
  watch: {
    modelValue(e) {
      this.updateActiveTab(e);
    },
    items() {
      for (; this.activeTabIndex > 0 && !this.tabsItems[this.activeTabIndex]; )
        this.activeTabIndex--;
      this.noSlider || this.$nextTick(this.updateSlider);
    },
    fillBar() {
      this.noSlider || this.$nextTick(this.updateSlider);
    },
    noSlider(e) {
      e ? window.removeEventListener("resize", this.onResize) : (this.updateSlider(), window.addEventListener("resize", this.onResize));
    }
  }
}, vs = /* @__PURE__ */ v(ws, [["render", ys]]), ks = { ref: "colgroup" }, _s = ["width"], Cs = { key: 0 }, Bs = ["onClick"], Ss = ["innerHTML"], $s = {
  key: 0,
  class: "w-table__progress-bar"
}, Vs = ["colspan"], Is = {
  key: 0,
  class: "w-table__progress-bar"
}, Rs = ["colspan"], Ls = { class: "w-table__loading-text" }, Ts = {
  key: 1,
  class: "no-data"
}, xs = ["colspan"], Ps = ["onClick"], Os = ["data-label"], zs = ["data-label"], Es = ["innerHTML"], Ms = {
  key: 2,
  class: "w-table__row w-table__row--expansion"
}, Ns = ["colspan"], Ws = { key: 0 }, As = {
  key: 3,
  class: "w-table__extra-row"
}, Ks = {
  key: 1,
  class: "w-table__footer"
}, Ds = {
  key: 1,
  class: "w-table__row"
}, Fs = ["colspan"], Hs = {
  key: 2,
  class: "w-table__row w-table__pagination-wrap"
}, js = ["colspan"], Us = { class: "w-table__pagination" }, qs = { class: "pagination-arrows" }, Gs = { class: "pagination-number pagination-number--results" };
function Xs(e, t, l, a, o, i) {
  const n = $("w-icon"), r = $("w-progress"), d = $("w-transition-fade"), h = $("w-transition-expand"), y = $("w-select"), S = $("w-button");
  return s(), u("div", {
    class: f(["w-table-wrap", i.wrapClasses])
  }, [
    w("table", {
      class: f(["w-table", i.classes]),
      onMousedown: t[4] || (t[4] = (...b) => i.onMouseDown && i.onMouseDown(...b)),
      onMouseover: t[5] || (t[5] = (...b) => i.onMouseOver && i.onMouseOver(...b)),
      onMouseout: t[6] || (t[6] = (...b) => i.onMouseOut && i.onMouseOut(...b))
    }, [
      w("colgroup", ks, [
        (s(!0), u(_, null, T(l.headers, (b, R) => (s(), u("col", {
          class: "w-table__col",
          key: R,
          width: b.width || null
        }, null, 8, _s))), 128))
      ], 512),
      l.noHeaders ? c("", !0) : (s(), u("thead", Cs, [
        w("tr", null, [
          (s(!0), u(_, null, T(l.headers, (b, R) => (s(), u("th", {
            class: f(["w-table__header", i.headerClasses(b)]),
            key: R,
            onClick: (P) => !e.colResizing.dragging && b.sortable !== !1 && i.sortTable(b)
          }, [
            b.sortable !== !1 && b.align === "right" ? (s(), g(n, {
              key: 0,
              class: f(["w-table__header-sort", i.headerSortClasses(b)])
            }, {
              default: m(() => [
                C("wi-arrow-down")
              ]),
              _: 2
            }, 1032, ["class"])) : c("", !0),
            b.label ? (s(), u(_, { key: 1 }, [
              e.$slots["header-label"] ? p(e.$slots, "header-label", {
                key: 0,
                header: b,
                label: b.label,
                index: R + 1
              }, () => [
                C(k(b.label || ""), 1)
              ]) : (s(), u("span", {
                key: 1,
                innerHTML: b.label || ""
              }, null, 8, Ss))
            ], 64)) : c("", !0),
            b.sortable !== !1 && b.align !== "right" ? (s(), g(n, {
              key: 2,
              class: f(["w-table__header-sort", i.headerSortClasses(b)])
            }, {
              default: m(() => [
                C("wi-arrow-down")
              ]),
              _: 2
            }, 1032, ["class"])) : c("", !0),
            R < l.headers.length - 1 && l.resizableColumns ? (s(), u("span", {
              key: 3,
              class: f(["w-table__col-resizer", { "w-table__col-resizer--hover": e.colResizing.hover === R, "w-table__col-resizer--active": e.colResizing.columnIndex === R }]),
              onClick: t[0] || (t[0] = E(() => {
              }, ["stop"]))
            }, null, 2)) : c("", !0)
          ], 10, Bs))), 128))
        ]),
        I(d, null, {
          default: m(() => [
            l.loading === "header" ? (s(), u("tr", $s, [
              w("td", {
                colspan: l.headers.length
              }, [
                I(r, { tile: "" })
              ], 8, Vs)
            ])) : c("", !0)
          ]),
          _: 1
        })
      ])),
      w("tbody", null, [
        l.loading === !0 ? (s(), u("tr", Is, [
          w("td", {
            colspan: l.headers.length
          }, [
            I(r, { tile: "" }),
            w("div", Ls, [
              p(e.$slots, "loading", {}, () => [
                C("Loading...")
              ])
            ])
          ], 8, Rs)
        ])) : i.tableItems.length ? c("", !0) : (s(), u("tr", Ts, [
          w("td", {
            class: "w-table__cell text-center",
            colspan: l.headers.length
          }, [
            p(e.$slots, "no-data", {}, () => [
              C("No data to show.")
            ])
          ], 8, xs)
        ])),
        i.tableItems.length && l.loading !== !0 ? (s(!0), u(_, { key: 2 }, T(i.paginatedItems, (b, R) => (s(), u(_, { key: R }, [
          e.$slots.item ? p(e.$slots, "item", {
            key: 0,
            item: b,
            index: R + 1,
            select: () => i.doSelectRow(b, R),
            classes: { "w-table__row": !0, "w-table__row--selected": i.selectedRowsByUid[b._uid] !== void 0, "w-table__row--expanded": i.expandedRowsByUid[b._uid] !== void 0 }
          }) : (s(), u("tr", {
            key: 1,
            class: f(["w-table__row", { "w-table__row--selected": i.selectedRowsByUid[b._uid] !== void 0, "w-table__row--expanded": i.expandedRowsByUid[b._uid] !== void 0 }]),
            onClick: (P) => i.doSelectRow(b, R)
          }, [
            (s(!0), u(_, null, T(l.headers, (P, O) => (s(), u(_, null, [
              e.$slots[`item-cell.${P.key}`] || e.$slots[`item-cell.${O + 1}`] || e.$slots["item-cell"] ? (s(), u("td", {
                class: f(["w-table__cell", { [`text-${P.align || "left"}`]: !0, "w-table__cell--sticky": P.sticky }]),
                key: `${O}-a`,
                "data-label": P.label
              }, [
                e.$slots[`item-cell.${P.key}`] ? p(e.$slots, `item-cell.${P.key}`, {
                  key: 0,
                  header: P,
                  item: b,
                  label: b[P.key] || "",
                  index: R + 1
                }) : e.$slots[`item-cell.${O + 1}`] ? p(e.$slots, `item-cell.${O + 1}`, {
                  key: 1,
                  header: P,
                  item: b,
                  label: b[P.key] || "",
                  index: R + 1
                }) : e.$slots["item-cell"] ? p(e.$slots, "item-cell", {
                  key: 2,
                  header: P,
                  item: b,
                  label: b[P.key] || "",
                  index: R + 1
                }) : c("", !0),
                O < l.headers.length - 1 && l.resizableColumns ? (s(), u("span", {
                  key: 3,
                  class: f(["w-table__col-resizer", { "w-table__col-resizer--hover": e.colResizing.hover === O, "w-table__col-resizer--active": e.colResizing.columnIndex === O }])
                }, null, 2)) : c("", !0)
              ], 10, Os)) : (s(), u("td", {
                class: f(["w-table__cell", { [`text-${P.align || "left"}`]: !0, "w-table__cell--sticky": P.sticky }]),
                key: `${O}-b`,
                "data-label": P.label
              }, [
                w("div", {
                  innerHTML: b[P.key] || ""
                }, null, 8, Es),
                O < l.headers.length - 1 && l.resizableColumns ? (s(), u("span", {
                  key: 0,
                  class: f(["w-table__col-resizer", { "w-table__col-resizer--hover": e.colResizing.hover === O, "w-table__col-resizer--active": e.colResizing.columnIndex === O }])
                }, null, 2)) : c("", !0)
              ], 10, zs))
            ], 64))), 256))
          ], 10, Ps)),
          i.expandedRowsByUid[b._uid] ? (s(), u("tr", Ms, [
            w("td", {
              class: "w-table__cell",
              colspan: l.headers.length
            }, [
              I(h, { y: "" }, {
                default: m(() => [
                  i.expandedRowsByUid[b._uid] ? (s(), u("div", Ws, [
                    p(e.$slots, "row-expansion", {
                      item: b,
                      index: R + 1
                    })
                  ])) : c("", !0),
                  R < l.headers.length - 1 && l.resizableColumns ? (s(), u("span", {
                    key: 1,
                    class: f(["w-table__col-resizer", { "w-table__col-resizer--hover": e.colResizing.hover === R, "w-table__col-resizer--active": e.colResizing.columnIndex === e.j }])
                  }, null, 2)) : c("", !0)
                ]),
                _: 2
              }, 1024)
            ], 8, Ns)
          ])) : c("", !0)
        ], 64))), 128)) : c("", !0),
        e.$slots["extra-row"] ? (s(), u("div", As, [
          p(e.$slots, "extra-row")
        ])) : c("", !0)
      ]),
      e.$slots.footer || e.$slots["footer-row"] || l.pagination ? (s(), u("tfoot", Ks, [
        e.$slots["footer-row"] ? p(e.$slots, "footer-row", { key: 0 }) : e.$slots.footer ? (s(), u("tr", Ds, [
          w("td", {
            class: "w-table__cell",
            colspan: l.headers.length
          }, [
            p(e.$slots, "footer")
          ], 8, Fs)
        ])) : c("", !0),
        l.pagination && e.paginationConfig ? (s(), u("tr", Hs, [
          w("td", {
            class: "w-table__cell",
            colspan: l.headers.length
          }, [
            w("div", Us, [
              C(k(e.paginationConfig), 1),
              p(e.$slots, "pagination", {
                range: `${e.paginationConfig.start}-${e.paginationConfig.end} of ${e.paginationConfig.total}`,
                total: e.paginationConfig.total
              }, () => [
                e.paginationConfig.itemsPerPageOptions ? (s(), g(y, {
                  key: 0,
                  class: "pagination-number pagination-number--items-per-page",
                  modelValue: e.paginationConfig.itemsPerPage,
                  "onUpdate:modelValue": t[1] || (t[1] = (b) => e.paginationConfig.itemsPerPage = b),
                  onInput: i.updatePaginationConfig,
                  items: e.paginationConfig.itemsPerPageOptions,
                  "label-position": "left",
                  label: "Items per page",
                  "label-color": "inherit"
                }, null, 8, ["modelValue", "onInput", "items"])) : c("", !0),
                w("div", qs, [
                  I(S, {
                    class: "pagination-arrow pagination-arrow--prev",
                    onClick: t[2] || (t[2] = (b) => i.goToPage("-1")),
                    disabled: e.paginationConfig.page <= 1,
                    icon: "wi-chevron-left",
                    text: "",
                    lg: ""
                  }, null, 8, ["disabled"]),
                  (s(!0), u(_, null, T(e.paginationConfig.pagesCount, (b) => (s(), g(S, {
                    class: "pagination-arrow pagination-arrow--prev",
                    key: b,
                    onClick: (R) => i.goToPage(b),
                    round: "",
                    text: "",
                    lg: ""
                  }, {
                    default: m(() => [
                      C(k(b), 1)
                    ]),
                    _: 2
                  }, 1032, ["onClick"]))), 128)),
                  I(S, {
                    class: "pagination-arrow pagination-arrow--next",
                    onClick: t[3] || (t[3] = (b) => i.goToPage("+1")),
                    disabled: e.paginationConfig.page >= e.paginationConfig.pagesCount,
                    icon: "wi-chevron-right",
                    text: "",
                    lg: ""
                  }, null, 8, ["disabled"])
                ]),
                w("span", Gs, k(e.paginationConfig.start) + "-" + k(e.paginationConfig.end) + " of " + k(e.paginationConfig.total), 1)
              ])
            ])
          ], 8, js)
        ])) : c("", !0)
      ])) : c("", !0)
    ], 34)
  ], 2);
}
const ce = 15, Ys = {
  name: "w-table",
  props: {
    items: { type: Array, required: !0 },
    headers: { type: Array, required: !0 },
    noHeaders: { type: Boolean },
    fixedLayout: { type: Boolean },
    fixedHeaders: { type: Boolean },
    fixedFooter: { type: Boolean },
    loading: { type: [Boolean, String] },
    sort: { type: [String, Array] },
    expandableRows: {
      validator: (e) => ([void 0, !0, !1, 1, "1", ""].includes(e) || le(
        `Wrong value for the w-table's \`expandableRows\` prop. Given: "${e}", expected one of: [undefined, true, false, 1, '1', ''].`
      ), !0)
    },
    expandedRows: { type: Array },
    selectableRows: {
      validator: (e) => ([void 0, !0, !1, 1, "1", ""].includes(e) || le(
        `Wrong value for the w-table's \`selectableRows\` prop. Given: "${e}", expected one of: [undefined, true, false, 1, '1', ''].`
      ), !0)
    },
    selectedRows: { type: Array },
    forceSelection: { type: Boolean },
    uidKey: { type: String, default: "id" },
    filter: { type: Function },
    sortFunction: { type: Function },
    mobileBreakpoint: { type: Number, default: 0 },
    resizableColumns: { type: Boolean },
    pagination: {
      type: [Boolean, Object, String],
      validator: (e) => {
        if (e) {
          if (typeof e == "object" && (!e.itemsPerPage || e.page && isNaN(e.page)))
            return le(
              "Wrong pagination config received in the w-table's `pagination` prop (received: `" + JSON.stringify(e) + "`). \nExpected object: { itemsPerPage: Integer, page: Integer } or { itemsPerPage: Integer, start: Integer }."
            ), !1;
        } else
          return !0;
        return !0;
      }
    },
    dark: { type: Boolean },
    light: { type: Boolean }
  },
  emits: [
    "row-select",
    "row-expand",
    "row-click",
    "update:sort",
    "update:selected-rows",
    "update:expanded-rows",
    "column-resize"
  ],
  data: () => ({
    activeSorting: [],
    selectedRowsInternal: [],
    expandedRowsInternal: [],
    colResizing: {
      dragging: !1,
      hover: !1,
      columnIndex: null,
      startCursorX: null,
      colWidth: null,
      nextColWidth: null,
      columnEl: null,
      nextColumnEl: null
    },
    paginationConfig: {}
  }),
  computed: {
    tableItems() {
      return this.items.map((e, t) => (e._uid = e[this.uidKey] !== void 0 ? e[this.uidKey] : t, e));
    },
    filteredItems() {
      return typeof this.filter == "function" ? this.tableItems.filter(this.filter) : this.tableItems;
    },
    sortedItems() {
      if (!this.activeSorting.length || this.sortFunction)
        return this.filteredItems;
      const e = this.activeSorting[0].replace(/^[+-]/, ""), t = this.activeSorting[0][0] === "-";
      return [...this.filteredItems].sort((l, a) => (l = l[e], a = a[e], !isNaN(l) && !isNaN(a) && (l = parseFloat(l), a = parseFloat(a)), (l > a ? 1 : -1) * (t ? -1 : 1)));
    },
    activeSortingKeys() {
      return this.activeSorting.reduce((e, t) => (e[t.replace(/^[+-]/, "")] = t[0], e), {});
    },
    wrapClasses() {
      return {
        "w-table-wrap--loading": this.loading
      };
    },
    classes() {
      return {
        "w-table--fixed-layout": this.fixedLayout || this.resizableColumns || this.hasStickyColumn,
        "w-table--mobile": this.isMobile || null,
        "w-table--resizable-cols": this.resizableColumns || null,
        "w-table--resizing": this.colResizing.dragging,
        "w-table--fixed-header": this.fixedHeaders,
        "w-table--fixed-footer": this.fixedFooter,
        "w-table--sticky-column": this.hasStickyColumn,
        "w-table--dark": this.dark,
        "w-table--light": this.light
      };
    },
    isMobile() {
      return ~~this.mobileBreakpoint && this.$waveui.breakpoint.width <= ~~this.mobileBreakpoint;
    },
    hasStickyColumn() {
      return this.headers.find((e) => e.sticky);
    },
    selectedRowsByUid() {
      return this.selectedRowsInternal.reduce((e, t) => (e[t] = !0) && e, {});
    },
    expandedRowsByUid() {
      return this.expandedRowsInternal.reduce((e, t) => (e[t] = !0) && e, {});
    },
    paginatedItems() {
      return this.sortedItems.slice(this.paginationConfig.start, this.paginationConfig.end);
    }
  },
  methods: {
    headerClasses(e) {
      return {
        "w-table__header--sortable": e.sortable !== !1,
        "w-table__header--sticky": e.sticky,
        "w-table__header--resizable": !!this.resizableColumns,
        [`text-${e.align || "left"}`]: !0
      };
    },
    headerSortClasses(e) {
      const t = this.activeSortingKeys[e.key];
      return [
        `w-table__header-sort--${t ? "active" : "inactive"}`,
        `w-table__header-sort--${t === "-" ? "desc" : "asc"}`,
        `m${e.align === "right" ? "r" : "l"}1`
      ];
    },
    async sortTable(e) {
      const t = this.activeSortingKeys[e.key];
      t && this.activeSortingKeys[e.key] === "-" ? this.activeSorting = [] : this.activeSorting[0] = (t ? "-" : "+") + e.key, this.$emit("update:sort", this.activeSorting), typeof this.sortFunction == "function" && await this.sortFunction(this.activeSorting);
    },
    doSelectRow(e, t) {
      const l = this.expandableRows === "" ? !0 : this.expandableRows, a = this.selectableRows === "" ? !0 : this.selectableRows;
      if (l) {
        const o = this.expandedRowsByUid[e._uid] === void 0;
        o ? this.expandableRows.toString() === "1" ? this.expandedRowsInternal = [e._uid] : this.expandedRowsInternal.push(e._uid) : this.expandedRowsInternal = this.expandedRowsInternal.filter((i) => i !== e._uid), this.$emit(
          "row-expand",
          {
            item: e,
            index: t,
            expanded: o,
            expandedRows: this.expandedRowsInternal.map((i) => this.filteredItems[i])
          }
        ), this.$emit("update:expanded-rows", this.expandedRowsInternal);
      } else if (a) {
        let o = !1;
        const i = this.selectedRowsByUid[e._uid] === void 0;
        i ? (this.selectableRows.toString() === "1" ? this.selectedRowsInternal = [e._uid] : this.selectedRowsInternal.push(e._uid), o = !0) : (!this.forceSelection || this.selectedRowsInternal.length > 1) && (this.selectedRowsInternal = this.selectedRowsInternal.filter((n) => n !== e._uid), o = !0), o && (this.$emit(
          "row-select",
          {
            item: e,
            index: t,
            selected: i,
            selectedRows: this.selectedRowsInternal.map((n) => this.filteredItems[n])
          }
        ), this.$emit("update:selected-rows", this.selectedRowsInternal));
      }
      this.$emit("row-click", { item: e, index: t });
    },
    onMouseDown(e) {
      e.target.classList.contains("w-table__col-resizer") && (this.colResizing.columnIndex = +e.target.parentNode.cellIndex, this.colResizing.startCursorX = e.pageX, this.colResizing.columnEl = this.$el.querySelector(`col:nth-child(${this.colResizing.columnIndex + 1})`), this.colResizing.nextColumnEl = this.colResizing.columnEl.nextSibling, this.colResizing.colWidth = this.colResizing.columnEl.offsetWidth, this.colResizing.nextColWidth = this.colResizing.nextColumnEl.offsetWidth, document.addEventListener("mousemove", this.onResizerMouseMove), document.addEventListener("mouseup", this.onResizerMouseUp));
    },
    onMouseOver({ target: e }) {
      e.classList.contains("w-table__col-resizer") && (this.colResizing.hover = +e.parentNode.cellIndex);
    },
    onMouseOut({ target: e }) {
      e.classList.contains("w-table__col-resizer") && (this.colResizing.hover = !1);
    },
    onResizerMouseMove(e) {
      const { startCursorX: t, columnEl: l, nextColumnEl: a, colWidth: o, nextColWidth: i } = this.colResizing;
      this.colResizing.dragging = !0;
      const n = e.pageX - t, r = o + i, d = o + n, h = i - n;
      l.style.width = o + n + "px", a.style.width = i - n + "px";
      const y = n < 0 && l.offsetWidth > d || l.offsetWidth <= ce, S = n > 0 && a.offsetWidth > h;
      if (y) {
        const b = Math.max(l.offsetWidth, ce);
        l.style.width = b + "px", a.style.width = r - b + "px";
      } else
        S && (l.style.width = r - a.offsetWidth + "px", a.style.width = a.offsetWidth + "px");
    },
    onResizerMouseUp() {
      document.removeEventListener("mousemove", this.onResizerMouseMove), document.removeEventListener("mouseup", this.onResizerMouseUp), setTimeout(() => {
        const e = [...this.$refs.colgroup.childNodes].map((t) => {
          var l;
          return ((l = t.style) == null ? void 0 : l.width) || t.offsetWidth;
        });
        this.$emit("column-resize", { index: this.colResizing.columnIndex, widths: e }), this.colResizing.dragging = !1, this.colResizing.columnIndex = null, this.colResizing.startCursorX = null, this.colResizing.columnEl = null, this.colResizing.nextColumnEl = null, this.colResizing.colWidth = null, this.colResizing.nextColWidth = null;
      }, 0);
    },
    updatePaginationConfig() {
      var i, n, r, d, h;
      const e = ((i = this.pagination) == null ? void 0 : i.itemsPerPage) || 20, t = ((n = this.pagination) == null ? void 0 : n.itemsPerPageOptions) || [20, 100, { label: "All", value: 0 }], l = ((r = this.pagination) == null ? void 0 : r.total) || this.items.length, a = e || l, o = ((d = this.pagination) == null ? void 0 : d.page) || 1;
      this.paginationConfig = {
        itemsPerPage: e,
        itemsPerPageOptions: t.map((y) => {
          var S;
          return {
            label: ["string", "number"].includes(typeof y) ? y.toString() : y.label || y.value,
            value: ["string", "number"].includes(typeof y) ? ~~y : (S = y.value) != null ? S : y.label
          };
        }),
        page: o,
        start: ((h = this.pagination) == null ? void 0 : h.start) || 1,
        end: l >= a * o ? a * o : l % (a * o),
        total: l,
        pagesCount: Math.ceil(l / a)
      };
    },
    goToPage(e) {
      ["-1", "+1"].includes(e) ? this.paginationConfig.page += +e : this.paginationConfig.page = e;
      const { itemsPerPage: t } = this.paginationConfig;
      this.paginationConfig.page = Math.max(1, this.paginationConfig.page), this.paginationConfig.start = t * (this.paginationConfig.page - 1) + 1, this.paginationConfig.end = this.paginationConfig.start - 1 + t;
    }
  },
  created() {
    this.sort ? this.activeSorting = Array.isArray(this.sort) ? this.sort : [this.sort] : this.activeSorting = [], (this.expandedRows || []).length && (this.expandedRowsInternal = this.expandedRows), (this.selectedRows || []).length && (this.selectedRowsInternal = this.selectedRows), this.pagination && this.updatePaginationConfig();
  },
  watch: {
    sort(e) {
      e ? this.activeSorting = Array.isArray(e) ? e : [e] : this.activeSorting = [];
    },
    expandableRows(e) {
      e ? e.toString() === "1" && (this.expandedRowsInternal = this.expandedRowsInternal.slice(0, 1)) : this.expandedRowsInternal = [];
    },
    expandedRows(e) {
      this.expandedRowsInternal = Array.isArray(e) && e.length ? this.expandedRows : [];
    },
    selectableRows(e) {
      e ? e.toString() === "1" && (this.selectedRowsInternal = this.selectedRowsInternal.slice(0, 1)) : this.selectedRowsInternal = [];
    },
    selectedRows(e) {
      this.selectedRowsInternal = Array.isArray(e) && e.length ? this.selectedRows : [];
    },
    pagination: {
      handler() {
        this.updatePaginationConfig();
      },
      deep: !0
    }
  }
}, Js = /* @__PURE__ */ v(Ys, [["render", Xs]]), Qs = ["role", "aria-pressed", "tabindex"];
function Zs(e, t, l, a, o, i) {
  return s(), u("span", B({ class: "w-tag" }, N(e.$attrs, !0), {
    onClick: t[1] || (t[1] = (n) => {
      e.$emit("update:modelValue", !l.modelValue), e.$emit("input", !l.modelValue);
    }),
    onKeypress: t[2] || (t[2] = M((n) => {
      e.$emit("update:modelValue", !l.modelValue), e.$emit("input", !l.modelValue);
    }, ["enter"])),
    class: i.classes,
    role: l.modelValue !== -1 && "button",
    "aria-pressed": l.modelValue !== -1 && (l.modelValue ? "true" : "false"),
    tabindex: l.modelValue !== -1 && 0,
    style: i.styles
  }), [
    p(e.$slots, "default"),
    l.closable && l.modelValue ? (s(), u("i", {
      key: 0,
      class: "w-icon w-tag__closable wi-cross",
      onClick: t[0] || (t[0] = E((n) => {
        e.$emit("update:modelValue", !1), e.$emit("input", !1);
      }, ["stop"])),
      role: "icon",
      "aria-hidden": "true"
    })) : c("", !0)
  ], 16, Qs);
}
const ea = {
  name: "w-tag",
  props: {
    modelValue: { type: [Boolean, Number], default: -1 },
    color: { type: String },
    bgColor: { type: String },
    shadow: { type: Boolean },
    tile: { type: Boolean },
    round: { type: Boolean },
    closable: { type: Boolean },
    outline: { type: Boolean },
    noBorder: { type: Boolean },
    xs: { type: Boolean },
    sm: { type: Boolean },
    md: { type: Boolean },
    lg: { type: Boolean },
    xl: { type: Boolean },
    width: { type: [Number, String] },
    height: { type: [Number, String] },
    dark: { type: Boolean },
    light: { type: Boolean }
  },
  emits: ["input", "update:modelValue"],
  computed: {
    presetSize() {
      return this.xs && "xs" || this.sm && "sm" || this.lg && "lg" || this.xl && "xl" || "md";
    },
    classes() {
      return {
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor,
        [`size--${this.presetSize}`]: !0,
        "w-tag--dark": this.dark,
        "w-tag--light": this.light,
        "w-tag--clickable": this.modelValue !== -1,
        "w-tag--outline": this.outline,
        "w-tag--no-border": this.noBorder || this.shadow,
        "w-tag--tile": this.tile,
        "w-tag--round": this.round,
        "w-tag--shadow": this.shadow
      };
    },
    styles() {
      return {
        width: (isNaN(this.width) ? this.width : `${this.width}px`) || null,
        height: (isNaN(this.height) ? this.height : `${this.height}px`) || null
      };
    }
  }
}, ta = /* @__PURE__ */ v(ea, [["render", Zs]]), la = ["for"], ia = ["id", "name", "placeholder", "rows", "cols", "readonly", "aria-readonly", "disabled", "required", "tabindex"], sa = ["for"], aa = ["for"];
function oa(e, t, l, a, o, i) {
  const n = $("w-icon");
  return s(), g(V(e.formRegister ? "w-form-element" : "div"), B({ ref: "formEl" }, e.formRegister && { validators: e.validators, inputValue: o.inputValue, disabled: e.isDisabled, readonly: e.isReadonly, isFocused: o.isFocused }, {
    valid: e.valid,
    "onUpdate:valid": t[6] || (t[6] = (r) => e.valid = r),
    wrap: i.hasLabel && l.labelPosition !== "inside",
    onReset: t[7] || (t[7] = (r) => {
      e.$emit("update:modelValue", o.inputValue = ""), e.$emit("input", "");
    }),
    class: i.classes
  }), {
    default: m(() => [
      l.labelPosition === "left" ? (s(), u(_, { key: 0 }, [
        e.$slots.default || l.label ? (s(), u("label", {
          key: 0,
          class: f(["w-textarea__label w-textarea__label--left w-form-el-shakable", e.labelClasses]),
          for: `w-textarea--${e._.uid}`
        }, [
          p(e.$slots, "default", {}, () => [
            C(k(l.label), 1)
          ])
        ], 10, la)) : c("", !0)
      ], 64)) : c("", !0),
      w("div", {
        class: f(["w-textarea__textarea-wrap", i.inputWrapClasses])
      }, [
        l.innerIconLeft ? (s(), g(n, {
          key: 0,
          class: "w-textarea__icon w-textarea__icon--inner-left",
          tag: "label",
          for: `w-textarea--${e._.uid}`,
          onClick: t[0] || (t[0] = (r) => e.$emit("click:inner-icon-left", r))
        }, {
          default: m(() => [
            C(k(l.innerIconLeft), 1)
          ]),
          _: 1
        }, 8, ["for"])) : c("", !0),
        D(w("textarea", B({
          class: "w-textarea__textarea",
          ref: "textarea",
          "onUpdate:modelValue": t[1] || (t[1] = (r) => o.inputValue = r)
        }, N(i.listeners, !0), {
          onInput: t[2] || (t[2] = (...r) => i.onInput && i.onInput(...r)),
          onFocus: t[3] || (t[3] = (...r) => i.onFocus && i.onFocus(...r)),
          onBlur: t[4] || (t[4] = (...r) => i.onBlur && i.onBlur(...r)),
          id: `w-textarea--${e._.uid}`,
          name: e.inputName,
          placeholder: l.placeholder || null,
          rows: l.rows || null,
          cols: l.cols || null,
          readonly: e.isReadonly || null,
          "aria-readonly": e.isReadonly ? "true" : "false",
          disabled: e.isDisabled || null,
          required: e.required || null,
          tabindex: e.tabindex || null
        }), null, 16, ia), [
          [ge, o.inputValue]
        ]),
        l.labelPosition === "inside" && i.showLabelInside ? (s(), u(_, { key: 1 }, [
          e.$slots.default || l.label ? (s(), u("label", {
            key: 0,
            class: f(["w-textarea__label w-textarea__label--inside w-form-el-shakable", e.labelClasses]),
            for: `w-textarea--${e._.uid}`
          }, [
            p(e.$slots, "default", {}, () => [
              C(k(l.label), 1)
            ])
          ], 10, sa)) : c("", !0)
        ], 64)) : c("", !0),
        l.innerIconRight ? (s(), g(n, {
          key: 2,
          class: "w-textarea__icon w-textarea__icon--inner-right",
          tag: "label",
          for: `w-textarea--${e._.uid}`,
          onClick: t[5] || (t[5] = (r) => e.$emit("click:inner-icon-right", r))
        }, {
          default: m(() => [
            C(k(l.innerIconRight), 1)
          ]),
          _: 1
        }, 8, ["for"])) : c("", !0)
      ], 2),
      l.labelPosition === "right" ? (s(), u(_, { key: 1 }, [
        e.$slots.default || l.label ? (s(), u("label", {
          key: 0,
          class: f(["w-textarea__label w-textarea__label--right w-form-el-shakable", e.labelClasses]),
          for: `w-textarea--${e._.uid}`
        }, [
          p(e.$slots, "default", {}, () => [
            C(k(l.label), 1)
          ])
        ], 10, aa)) : c("", !0)
      ], 64)) : c("", !0)
    ]),
    _: 3
  }, 16, ["valid", "wrap", "class"]);
}
const na = {
  name: "w-textarea",
  mixins: [z],
  props: {
    modelValue: { default: "" },
    label: { type: String },
    labelPosition: { type: String, default: "inside" },
    innerIconLeft: { type: String },
    innerIconRight: { type: String },
    staticLabel: { type: Boolean },
    placeholder: { type: String },
    color: { type: String, default: "primary" },
    bgColor: { type: String },
    labelColor: { type: String, default: "primary" },
    outline: { type: Boolean },
    shadow: { type: Boolean },
    noAutogrow: { type: Boolean },
    resizable: { type: Boolean },
    tile: { type: Boolean },
    rows: { type: [Number, String], default: 3 },
    cols: { type: [Number, String] },
    dark: { type: Boolean },
    light: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "focus", "blur", "click:inner-icon-left", "click:inner-icon-right"],
  data() {
    return {
      inputValue: this.modelValue,
      isFocused: !1,
      height: null,
      lineHeight: null,
      paddingY: null
    };
  },
  computed: {
    listeners() {
      const { input: e, focus: t, blur: l, ...a } = this.$attrs;
      return a;
    },
    hasValue() {
      return this.inputValue || this.inputValue === 0;
    },
    hasLabel() {
      return this.label || this.$slots.default;
    },
    showLabelInside() {
      return !this.staticLabel || !this.hasValue && !this.placeholder;
    },
    classes() {
      return {
        "w-textarea": !0,
        "w-textarea--disabled": this.isDisabled,
        "w-textarea--readonly": this.isReadonly,
        [`w-textarea--${this.hasValue ? "filled" : "empty"}`]: !0,
        "w-textarea--focused": this.isFocused && !this.isReadonly,
        "w-textarea--dark": this.dark,
        "w-textarea--light": this.light,
        "w-textarea--resizable": this.resizable,
        "w-textarea--floating-label": this.hasLabel && this.labelPosition === "inside" && !this.staticLabel,
        "w-textarea--no-padding": !this.outline && !this.bgColor && !this.shadow,
        "w-textarea--has-placeholder": this.placeholder,
        "w-textarea--inner-icon-left": this.innerIconLeft,
        "w-textarea--inner-icon-right": this.innerIconRight
      };
    },
    inputWrapClasses() {
      return {
        [this.valid === !1 ? this.validationColor : this.color]: this.color || this.valid === !1,
        [`${this.bgColor}--bg`]: this.bgColor,
        "w-textarea__textarea-wrap--tile": this.tile,
        "w-textarea__textarea-wrap--box": this.outline || this.bgColor || this.shadow,
        "w-textarea__textarea-wrap--underline": !this.outline,
        "w-textarea__textarea-wrap--shadow": this.shadow,
        "w-textarea__textarea-wrap--no-padding": !this.outline && !this.bgColor && !this.shadow
      };
    },
    textareaStyles() {
      return this.noAutogrow || this.resizable ? {} : {
        height: this.height ? `${this.height}px` : null
      };
    }
  },
  methods: {
    onInput() {
      !this.noAutogrow && !this.resizable && this.computeHeight(), this.$emit("update:modelValue", this.inputValue), this.$emit("input", this.inputValue);
    },
    onFocus(e) {
      this.isFocused = !0, this.$emit("focus", e);
    },
    onBlur(e) {
      this.isFocused = !1, this.$emit("blur", e);
    },
    computeHeight() {
      this.$refs.textarea.style.height = "";
      const e = (this.$refs.textarea.scrollHeight - this.paddingY) / this.lineHeight, t = Math.max(e, this.rows) * this.lineHeight + this.paddingY;
      this.$refs.textarea.style.height = t + "px";
    },
    getLineHeight() {
      const e = window.getComputedStyle(this.$refs.textarea, null);
      this.lineHeight = parseFloat(e.getPropertyValue("line-height")), this.paddingY = parseFloat(e.getPropertyValue("padding-top")), this.paddingY += parseFloat(e.getPropertyValue("padding-bottom"));
    }
  },
  mounted() {
    !this.noAutogrow && !this.resizable && (this.getLineHeight(), this.computeHeight());
  },
  watch: {
    modelValue(e) {
      this.inputValue = e, this.$nextTick(this.computeHeight);
    },
    resizable(e) {
      e ? this.height = null : this.noAutogrow || this.getLineHeight();
    },
    noAutogrow(e) {
      e ? this.getLineHeight() : this.height = null;
    }
  }
}, ra = /* @__PURE__ */ v(na, [["render", oa]]), da = ["innerHTML"], ua = ["innerHTML"];
function ha(e, t, l, a, o, i) {
  return s(), u("ul", {
    class: f(["w-timeline", i.classes])
  }, [
    (s(!0), u(_, null, T(l.items, (n, r) => (s(), u("li", {
      class: "w-timeline-item",
      key: r
    }, [
      (s(), g(V(n[l.itemIconKey] || l.icon ? "w-icon" : "div"), {
        class: f(["w-timeline-item__bullet", { [n[l.itemColorKey] || l.color]: n[l.itemColorKey] || l.color }])
      }, {
        default: m(() => [
          C(k(n[l.itemIconKey] || l.icon), 1)
        ]),
        _: 2
      }, 1032, ["class"])),
      e.$slots[`item.${r + 1}`] ? p(e.$slots, `item.${r + 1}`, {
        key: 1,
        item: n,
        index: r + 1
      }) : p(e.$slots, "item", {
        key: 0,
        item: n,
        index: r + 1
      }, () => [
        w("div", {
          class: f(["w-timeline-item__title", { [n[l.itemColorKey] || l.color]: n[l.itemColorKey] || l.color }]),
          innerHTML: n[l.itemTitleKey]
        }, null, 10, da),
        w("div", {
          class: "w-timeline-item__content",
          innerHTML: n[l.itemContentKey]
        }, null, 8, ua)
      ])
    ]))), 128))
  ], 2);
}
const ca = {
  name: "w-timeline",
  props: {
    items: { type: [Array, Number], required: !0 },
    color: { type: String },
    icon: { type: String },
    itemTitleKey: { type: String, default: "title" },
    itemContentKey: { type: String, default: "content" },
    itemIconKey: { type: String, default: "icon" },
    itemColorKey: { type: String, default: "color" },
    dark: { type: Boolean },
    light: { type: Boolean }
  },
  emits: [],
  computed: {
    classes() {
      return {
        "w-timeline--dark": this.dark,
        "w-timeline--light": this.light
      };
    }
  }
}, pa = /* @__PURE__ */ v(ca, [["render", ha]]);
function fa(e, t, l, a, o, i) {
  return s(), u("div", {
    class: f(["w-toolbar", i.classes]),
    style: L(i.styles)
  }, [
    p(e.$slots, "default")
  ], 6);
}
const ma = {
  name: "w-toolbar",
  props: {
    color: { type: String },
    bgColor: { type: String },
    absolute: { type: Boolean },
    fixed: { type: Boolean },
    bottom: { type: Boolean },
    vertical: { type: Boolean },
    left: { type: Boolean },
    right: { type: Boolean },
    width: { type: [Number, String], default: null },
    height: { type: [Number, String], default: null },
    noBorder: { type: Boolean },
    shadow: { type: Boolean },
    dark: { type: Boolean },
    light: { type: Boolean }
  },
  emits: [],
  computed: {
    toolbarHeight() {
      const e = this.height;
      return e && parseInt(e) == e ? e + "px" : e;
    },
    toolbarWidth() {
      const e = this.width;
      return e && parseInt(e) == e ? e + "px" : e;
    },
    classes() {
      return {
        [this.color]: !!this.color,
        [`${this.bgColor}--bg`]: !!this.bgColor,
        "w-toolbar--dark": this.dark,
        "w-toolbar--light": this.light,
        "w-toolbar--absolute": !!this.absolute,
        "w-toolbar--fixed": !!this.fixed,
        [`w-toolbar--${this.bottom ? "bottom" : "top"}`]: !this.vertical,
        [`w-toolbar--vertical w-toolbar--${this.right ? "right" : "left"}`]: this.vertical,
        "w-toolbar--no-border": this.noBorder,
        "w-toolbar--shadow": !!this.shadow
      };
    },
    styles() {
      return {
        height: this.height && !this.vertical ? this.toolbarHeight : null,
        width: this.width && this.vertical ? this.toolbarWidth : null
      };
    }
  }
}, ga = /* @__PURE__ */ v(ma, [["render", fa]]);
function ba(e, t, l, a, o, i) {
  return s(), u(_, null, [
    p(e.$slots, "activator", { on: i.activatorEventHandlers }),
    I(x, {
      name: i.transitionName,
      appear: ""
    }, {
      default: m(() => [
        e.detachableVisible ? (s(), u("div", {
          class: f(["w-tooltip", i.classes]),
          ref: "detachable",
          key: e._.uid,
          style: L(i.styles)
        }, [
          p(e.$slots, "default")
        ], 6)) : c("", !0)
      ]),
      _: 3
    }, 8, ["name"])
  ], 64);
}
const ya = {
  name: "w-tooltip",
  mixins: [ye],
  props: {
    modelValue: {},
    showOnClick: { type: Boolean },
    color: { type: String },
    bgColor: { type: String },
    noBorder: { type: Boolean },
    shadow: { type: Boolean },
    tile: { type: Boolean },
    round: { type: Boolean },
    transition: { type: String },
    tooltipClass: { type: [String, Object, Array] },
    persistent: { type: Boolean },
    delay: { type: Number },
    dark: { type: Boolean },
    light: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "open", "close"],
  data: () => ({
    detachableVisible: !1,
    hoveringActivator: !1,
    detachableCoords: {
      top: 0,
      left: 0
    },
    detachableEl: null,
    timeoutId: null
  }),
  computed: {
    tooltipClasses() {
      return W(this.tooltipClass);
    },
    transitionName() {
      const e = this.position.replace(/top|bottom/, (t) => ({ top: "up", bottom: "down" })[t]);
      return this.transition || `w-tooltip-slide-fade-${e}`;
    },
    classes() {
      return {
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor,
        ...this.tooltipClasses,
        [`w-tooltip--${this.position}`]: !this.noPosition,
        [`w-tooltip--align-${this.alignment}`]: !this.noPosition && this.alignment,
        "w-tooltip--dark": this.dark,
        "w-tooltip--light": this.light,
        "w-tooltip--tile": this.tile,
        "w-tooltip--round": this.round,
        "w-tooltip--shadow": this.shadow,
        "w-tooltip--fixed": this.fixed,
        "w-tooltip--no-border": this.noBorder || this.bgColor,
        "w-tooltip--custom-transition": this.transition
      };
    },
    styles() {
      return {
        zIndex: this.zIndex || this.zIndex === 0 || null,
        top: this.detachableCoords.top && `${~~this.detachableCoords.top}px` || null,
        left: this.detachableCoords.left && `${~~this.detachableCoords.left}px` || null,
        "--w-tooltip-bg-color": this.$waveui.colors[this.bgColor || "white"]
      };
    },
    activatorEventHandlers() {
      let e = {};
      return this.showOnClick ? e = { click: this.toggle } : (e = {
        focus: this.toggle,
        blur: this.toggle,
        mouseenter: (t) => {
          this.hoveringActivator = !0, this.open(t);
        },
        mouseleave: (t) => {
          this.hoveringActivator = !1, this.close();
        }
      }, typeof window < "u" && "ontouchstart" in window && (e.click = this.toggle)), e;
    }
  },
  methods: {
    toggle(e) {
      let t = this.detachableVisible;
      typeof window < "u" && "ontouchstart" in window ? e.type === "click" && (t = !t) : e.type === "click" && this.showOnClick ? t = !t : ["mouseenter", "focus"].includes(e.type) && !this.showOnClick ? t = !0 : ["mouseleave", "blur"].includes(e.type) && !this.showOnClick && (t = !1), this.timeoutId = clearTimeout(this.timeoutId), t ? this.open(e) : this.close();
    },
    async close(e = !1) {
      !this.detachableVisible || this.showOnHover && !e && (await new Promise((t) => setTimeout(t, 10)), this.showOnHover && this.hoveringActivator) || (this.$emit("update:modelValue", this.detachableVisible = !1), this.$emit("input", !1), this.$emit("close"), document.removeEventListener("mousedown", this.onOutsideMousedown), window.removeEventListener("resize", this.onResize));
    }
  }
}, wa = /* @__PURE__ */ v(ya, [["render", ba]]);
function va(e, t, l, a, o, i) {
  return s(), g(x, B({ name: "bounce" }, e.$props), {
    default: m(() => [
      p(e.$slots, "default")
    ]),
    _: 3
  }, 16);
}
const ka = {
  name: "w-transition-bounce",
  props: {
    appear: { type: Boolean },
    duration: { type: [Number, String] }
  }
}, _a = /* @__PURE__ */ v(ka, [["render", va]]);
function Ca(e, t, l, a, o, i) {
  return s(), g(x, {
    name: "expand",
    mode: "out-in",
    css: !1,
    onBeforeAppear: i.beforeAppear,
    onAppear: i.appear,
    onAfterAppear: i.afterAppear,
    onBeforeEnter: i.beforeEnter,
    onEnter: i.enter,
    onAfterEnter: i.afterEnter,
    onBeforeLeave: i.beforeLeave,
    onLeave: i.leave,
    onAfterLeave: i.afterLeave
  }, {
    default: m(() => [
      p(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["onBeforeAppear", "onAppear", "onAfterAppear", "onBeforeEnter", "onEnter", "onAfterEnter", "onBeforeLeave", "onLeave", "onAfterLeave"]);
}
const Ba = {
  name: "w-transition-expand",
  props: {
    x: { type: Boolean },
    y: { type: Boolean },
    duration: { type: Number, default: 250 }
  },
  data: () => ({
    el: {
      savedState: !1,
      originalStyles: "",
      width: 0,
      height: 0,
      marginLeft: 0,
      marginRight: 0,
      marginTop: 0,
      marginBottom: 0,
      paddingLeft: 0,
      paddingRight: 0,
      paddingTop: 0,
      paddingBottom: 0,
      borderLeftWidth: 0,
      borderRightWidth: 0,
      borderTopWidth: 0,
      borderBottomWidth: 0
    },
    cleanTransitionCycle: !0
  }),
  computed: {
    animX() {
      return this.x || !this.y;
    },
    animY() {
      return this.y || !this.x;
    }
  },
  methods: {
    beforeAppear(e) {
      this.cleanTransitionCycle && this.saveOriginalInlineStyles(e), this.cleanTransitionCycle = !1;
    },
    appear(e, t) {
      this.show(e), setTimeout(t, this.duration), this.cleanTransitionCycle = !1;
    },
    afterAppear(e) {
      this.applyOriginalStyles(e), e.style.cssText = e.style.cssText.replace("display: none;", ""), this.cleanTransitionCycle = !1;
    },
    beforeEnter(e) {
      this.cleanTransitionCycle && this.saveOriginalInlineStyles(e), this.cleanTransitionCycle = !1;
    },
    enter(e, t) {
      this.show(e), setTimeout(t, this.duration), this.cleanTransitionCycle = !1;
    },
    afterEnter(e) {
      this.applyOriginalStyles(e), e.style.cssText = e.style.cssText.replace("display: none;", ""), this.cleanTransitionCycle = !1;
    },
    beforeLeave(e) {
      this.el.savedState || this.saveComputedStyles(e), this.beforeHide(e), this.cleanTransitionCycle = !1;
    },
    leave(e, t) {
      this.hide(e), setTimeout(t, this.duration), this.cleanTransitionCycle = !1;
    },
    afterLeave(e) {
      this.applyOriginalStyles(e), this.cleanTransitionCycle = !0, this.el.savedState = !1;
    },
    applyHideStyles(e) {
      this.animX && (e.style.width = 0, e.style.marginLeft = 0, e.style.marginRight = 0, e.style.paddingLeft = 0, e.style.paddingRight = 0, e.style.borderLeftWidth = 0, e.style.borderRightWidth = 0), this.animY && (e.style.height = 0, e.style.marginTop = 0, e.style.marginBottom = 0, e.style.paddingTop = 0, e.style.paddingBottom = 0, e.style.borderTopWidth = 0, e.style.borderBottomWidth = 0), e.style.overflow = "hidden";
    },
    applyShowStyles(e) {
      this.animX && (e.style.width = this.el.width + "px", e.style.marginLeft = this.el.marginLeft, e.style.marginRight = this.el.marginRight, e.style.paddingLeft = this.el.paddingLeft, e.style.paddingRight = this.el.paddingRight, e.style.borderLeftWidth = this.el.borderLeftWidth, e.style.borderRightWidth = this.el.borderRightWidth), this.animY && (e.style.height = this.el.height + "px", e.style.marginTop = this.el.marginTop, e.style.marginBottom = this.el.marginBottom, e.style.paddingTop = this.el.paddingTop, e.style.paddingBottom = this.el.paddingBottom, e.style.borderTopWidth = this.el.borderTopWidth, e.style.borderBottomWidth = this.el.borderBottomWidth), e.style.transition = this.duration + "ms ease-in-out";
    },
    applyOriginalStyles(e) {
      e.style.cssText = this.el.originalStyles;
    },
    saveOriginalInlineStyles(e) {
      this.el.originalStyles = e.style.cssText;
    },
    show(e, t) {
      this.saveComputedStyles(e), this.applyHideStyles(e), setTimeout(() => this.applyShowStyles(e), 20), setTimeout(t, this.duration);
    },
    beforeHide(e) {
      this.applyShowStyles(e);
    },
    hide(e, t) {
      setTimeout(() => this.applyHideStyles(e), 20), setTimeout(t, this.duration);
    },
    saveComputedStyles(e) {
      const t = window.getComputedStyle(e, null);
      this.animX && (this.el.width = e.offsetWidth, this.el.marginLeft = t.getPropertyValue("marginLeft"), this.el.marginRight = t.getPropertyValue("marginRight"), this.el.paddingLeft = t.getPropertyValue("paddingLeft"), this.el.paddingRight = t.getPropertyValue("paddingRight"), this.el.borderLeftWidth = t.getPropertyValue("borderLeftWidth"), this.el.borderRightWidth = t.getPropertyValue("borderRightWidth")), this.animY && (this.el.height = e.offsetHeight, this.el.marginTop = t.getPropertyValue("marginTop"), this.el.marginBottom = t.getPropertyValue("marginBottom"), this.el.paddingTop = t.getPropertyValue("paddingTop"), this.el.paddingBottom = t.getPropertyValue("paddingBottom"), this.el.borderTopWidth = t.getPropertyValue("borderTopWidth"), this.el.borderBottomWidth = t.getPropertyValue("borderBottomWidth")), this.el.savedState = !0;
    }
  }
}, Sa = /* @__PURE__ */ v(Ba, [["render", Ca]]);
function $a(e, t, l, a, o, i) {
  return s(), g(x, B({ name: "fade" }, e.$props), {
    default: m(() => [
      p(e.$slots, "default")
    ]),
    _: 3
  }, 16);
}
const Va = {
  name: "w-transition-fade",
  props: {
    appear: { type: Boolean },
    duration: { type: [Number, String] }
  }
}, Ia = /* @__PURE__ */ v(Va, [["render", $a]]);
function Ra(e, t, l, a, o, i) {
  return s(), g(x, B({ name: "scale" }, e.$props), {
    default: m(() => [
      p(e.$slots, "default")
    ]),
    _: 3
  }, 16);
}
const La = {
  name: "w-transition-scale",
  props: {
    appear: { type: Boolean },
    duration: { type: [Number, String] }
  }
}, Ta = /* @__PURE__ */ v(La, [["render", Ra]]);
function xa(e, t, l, a, o, i) {
  return s(), g(x, B({ name: "scale-fade" }, e.$props), {
    default: m(() => [
      p(e.$slots, "default")
    ]),
    _: 3
  }, 16);
}
const Pa = {
  name: "w-transition-scale-fade",
  props: {
    appear: { type: Boolean },
    duration: { type: [Number, String] }
  }
}, Oa = /* @__PURE__ */ v(Pa, [["render", xa]]);
function za(e, t, l, a, o, i) {
  return s(), g(x, B({ name: i.transitionName }, e.$props), {
    default: m(() => [
      p(e.$slots, "default")
    ]),
    _: 3
  }, 16, ["name"]);
}
const Ea = {
  name: "w-transition-slide",
  props: {
    appear: { type: Boolean },
    left: { type: Boolean },
    right: { type: Boolean },
    up: { type: Boolean },
    down: { type: Boolean },
    duration: { type: [Number, String] }
  },
  computed: {
    direction() {
      return this.up && "up" || this.down && "down" || this.left && "left" || this.right && "right" || "down";
    },
    transitionName() {
      return `slide-${this.direction}`;
    }
  }
}, Ma = /* @__PURE__ */ v(Ea, [["render", za]]);
function Na(e, t, l, a, o, i) {
  return s(), g(x, B({ name: i.transitionName }, e.$props), {
    default: m(() => [
      p(e.$slots, "default")
    ]),
    _: 3
  }, 16, ["name"]);
}
const Wa = {
  name: "w-transition-slide-fade",
  props: {
    appear: { type: Boolean },
    left: { type: Boolean },
    right: { type: Boolean },
    up: { type: Boolean },
    down: { type: Boolean },
    duration: { type: [Number, String] }
  },
  computed: {
    direction() {
      return this.up && "up" || this.down && "down" || this.left && "left" || this.right && "right" || "down";
    },
    transitionName() {
      return `slide-fade-${this.direction}`;
    }
  }
}, Aa = /* @__PURE__ */ v(Wa, [["render", Na]]);
function Ka(e, t, l, a, o, i) {
  return s(), g(x, B({ name: "twist" }, e.$props), {
    default: m(() => [
      p(e.$slots, "default")
    ]),
    _: 3
  }, 16);
}
const Da = {
  name: "w-transition-twist",
  props: {
    appear: { type: Boolean },
    duration: { type: [Number, String] }
  }
}, Fa = /* @__PURE__ */ v(Da, [["render", Ka]]), Ha = ["innerHTML"], ja = {
  key: 1,
  class: "ml1"
};
function Ua(e, t, l, a, o, i) {
  const n = $("w-button"), r = $("w-icon"), d = $("w-tree", !0);
  return s(), u("ul", {
    class: f(["w-tree", i.classes])
  }, [
    (s(!0), u(_, null, T(e.currentDepthItems, (h, y) => (s(), u("li", {
      class: f(["w-tree__item", i.itemClasses(h)]),
      key: y
    }, [
      (s(), g(V(!l.disabled && !h.disabled && h.route ? !e.$router || i.hasExternalLink(h) ? "a" : "router-link" : "div"), B({ class: "w-tree__item-label" }, h.route && { [!e.$router || i.hasExternalLink(h) ? "href" : "to"]: h.route }, {
        onClick: (S) => !l.disabled && !h.disabled && i.onLabelClick(h, S),
        onKeydown: (S) => !l.disabled && !h.disabled && i.onLabelKeydown(h, S),
        tabindex: !l.disabled && !h.disabled && (h.children || h.branch || l.selectable) && !(l.unexpandableEmpty && !h.children) ? 0 : null
      }), {
        default: m(() => [
          (h.children || h.branch) && (l.expandOpenIcon && h.open || l.expandIcon) && !(l.unexpandableEmpty && !h.children) ? (s(), g(n, {
            key: 0,
            class: "w-tree__item-expand",
            onClick: E((S) => !l.disabled && !h.disabled && i.onLabelClick(h, S), ["stop"]),
            color: "inherit",
            icon: h.open && l.expandOpenIcon || l.expandIcon,
            "icon-props": { rotate90a: !h.open },
            tabindex: -1,
            disabled: l.disabled || h.disabled,
            text: "",
            sm: ""
          }, null, 8, ["onClick", "icon", "icon-props", "disabled"])) : c("", !0),
          p(e.$slots, "item", {
            item: h.originalItem,
            depth: l.depth,
            open: h.open
          }, () => {
            var S;
            return [
              i.itemIcon(h) ? (s(), g(r, {
                key: 0,
                class: "w-tree__item-icon",
                color: h.originalItem[l.itemIconColorKey] || l.iconColor
              }, {
                default: m(() => [
                  C(k(i.itemIcon(h)), 1)
                ]),
                _: 2
              }, 1032, ["color"])) : c("", !0),
              w("span", {
                innerHTML: h.label
              }, null, 8, Ha),
              l.counts && (h.children || h.branch) ? (s(), u("span", ja, "(" + k(((S = h.originalItem.children) == null ? void 0 : S.length) || 0) + ")", 1)) : c("", !0)
            ];
          })
        ]),
        _: 2
      }, 1040, ["onClick", "onKeydown", "tabindex"])),
      (s(), g(V(l.noTransition ? "div" : "w-transition-expand"), {
        y: !l.noTransition || null,
        onAfterEnter: (S) => e.$emit("open", { item: h.originalItem, open: h.open, depth: l.depth }),
        onAfterLeave: (S) => e.$emit("close", { item: h.originalItem, open: h.open, depth: l.depth })
      }, {
        default: m(() => [
          h.children && h.open ? (s(), g(d, B({ key: 0 }, e.$props, {
            depth: l.depth + 1,
            data: h.originalItem.children,
            onBeforeOpen: t[0] || (t[0] = (S) => e.$emit("before-open", S)),
            onOpen: t[1] || (t[1] = (S) => e.$emit("open", S)),
            onBeforeClose: t[2] || (t[2] = (S) => e.$emit("before-close", S)),
            onClose: t[3] || (t[3] = (S) => e.$emit("close", S)),
            onClick: t[4] || (t[4] = (S) => e.$emit("click", S)),
            onSelect: t[5] || (t[5] = (S) => e.$emit("select", S)),
            "onUpdate:modelValue": t[6] || (t[6] = (S) => e.$emit("update:model-value", S))
          }), {
            item: m(({ item: S, depth: b, open: R }) => [
              p(e.$slots, "item", {
                item: S,
                depth: b,
                open: R
              })
            ]),
            _: 2
          }, 1040, ["depth", "data"])) : c("", !0)
        ]),
        _: 2
      }, 1064, ["y", "onAfterEnter", "onAfterLeave"]))
    ], 2))), 128))
  ], 2);
}
const qa = {
  name: "w-tree",
  props: {
    modelValue: { type: [Object, Array] },
    data: { type: [Object, Array], required: !0 },
    depth: { type: Number, default: 0 },
    branchClass: { type: String },
    leafClass: { type: String },
    branchIcon: { type: String },
    branchOpenIcon: { type: String },
    leafIcon: { type: String },
    expandIcon: { type: [Boolean, String], default: "wi-triangle-down" },
    expandOpenIcon: { type: [Boolean, String] },
    expandAll: { type: Boolean },
    unexpandableEmpty: { type: Boolean },
    disabled: { type: Boolean },
    noTransition: { type: Boolean },
    selectable: { type: Boolean },
    deepReactivity: { type: Boolean },
    counts: { type: Boolean },
    itemIconKey: { type: String, default: "icon" },
    iconColor: { type: String },
    itemLabelKey: { type: String, default: "label" },
    itemIconColorKey: { type: String, default: "iconColor" },
    itemRouteKey: { type: String, default: "route" },
    itemDisabledKey: { type: String, default: "disabled" },
    itemOpenKey: { type: String, default: "open" }
  },
  emits: ["update:model-value", "before-open", "open", "before-close", "close", "click", "select"],
  data: () => ({
    currentDepthItems: [],
    dataPropUnwatch: null
  }),
  computed: {
    classes() {
      return {
        [`w-tree--depth${this.depth}`]: !0,
        "w-tree--expand-icon": this.expandIcon && !this.depth,
        "w-tree--disabled": this.disabled && !this.depth,
        "w-tree--no-expand-button": !this.expandIcon
      };
    }
  },
  methods: {
    updateCurrentDepthTree(e, t = []) {
      if (this.currentDepthItems = [], !Array.isArray(e) && typeof e != "object")
        return J(`[w-tree] the tree items must be of type array or object, ${typeof e} received.`);
      Array.isArray(e) || (e = [e]), e.forEach((l, a) => {
        var o;
        this.currentDepthItems.push({
          originalItem: l,
          _uid: this.depth.toString() + (a + 1),
          label: l[this.itemLabelKey],
          children: !!l.children,
          branch: l.branch,
          route: l[this.itemRouteKey],
          disabled: l[this.itemDisabledKey],
          depth: this.depth,
          open: !!(((o = t[a]) == null ? void 0 : o.open) || this.expandAll || l[this.itemOpenKey])
        });
      });
    },
    expandDepth(e, t) {
      typeof t == "boolean" ? e.open = t : e.open = !e.open;
      const l = { item: e.originalItem, open: e.open, depth: this.depth };
      return this.$emit(e.open ? "before-open" : "before-close", l), !this.unexpandableEmpty && !e.children && this.$emit(e.open ? "open" : "close", l), !0;
    },
    onLabelClick(e, t) {
      e[this.itemRouteKey] && this.$router && !this.hasExternalLink(e) && t.preventDefault(), this.$emit("click", { item: e.originalItem, depth: this.depth, e: t }), (e.children || e.branch && !this.unexpandableEmpty) && this.expandDepth(e), this.selectable && this.emitItemSelection(e, t);
    },
    emitItemSelection(e, t) {
      const l = { item: e.originalItem, depth: this.depth, e: t };
      (e.children || e.branch && !this.unexpandableEmpty) && (l.open = e.open), this.$emit("update:model-value", l), this.$emit("select", l);
    },
    onLabelKeydown(e, t) {
      if (!(t.metaKey || t.ctrlKey || t.altKey || t.shiftKey) && [13, 32, 37, 38, 39, 40].includes(t.which) && ((e.children || e.branch) && ([13, 32].includes(t.which) ? this.expandDepth(e) && t.preventDefault() : t.which === 37 ? this.expandDepth(e, !1) && t.preventDefault() : t.which === 39 && this.expandDepth(e, !0) && t.preventDefault()), [38, 40].includes(t.which))) {
        const a = this.$el.closest(".w-tree--depth0").querySelectorAll('.w-tree__item-label[tabindex="0"]'), o = t.target.closest(".w-tree__item-label"), i = t.which === 38 ? -1 : 1;
        [...a].some((n, r) => n.isSameNode(o) ? (a[r + i] && a[r + i].focus(), !0) : !1);
      }
      this.selectable && this.emitItemSelection(e, t);
    },
    getPreviousSibling(e, t) {
      for (; t && (e = e.previousElementSibling); )
        if (e.matches(t))
          return e;
      return !1;
    },
    getNextSibling(e, t) {
      for (; t && (e = e.nextElementSibling); )
        if (e.matches(t))
          return e;
      return !1;
    },
    focusTreeItem(e) {
      e && e.querySelector(".w-tree__item-label").focus();
    },
    itemIcon(e) {
      return e.originalItem[this.itemIconKey] || !e.children && !e.branch && this.leafIcon || (e.children || e.branch) && (e.open && this.branchOpenIcon || this.branchIcon);
    },
    hasExternalLink(e) {
      return /^(https?:)?\/\/|mailto:|tel:/.test(e[this.itemRouteKey]);
    },
    itemClasses(e) {
      return {
        [e.children || e.branch ? "w-tree__item--branch" : "w-tree__item--leaf"]: !0,
        "w-tree__item--disabled": e[this.itemDisabledKey],
        "w-tree__item--empty": e.branch && !e.children,
        "w-tree__item--unexpandable": e.branch && !e.children && this.unexpandableEmpty
      };
    }
  },
  created() {
    this.updateCurrentDepthTree(this.data), this.dataPropUnwatch = this.$watch(
      "data",
      (e) => this.updateCurrentDepthTree(e, this.currentDepthItems),
      { deep: !!this.deepReactivity }
    );
  },
  unmounted() {
    this.dataPropUnwatch();
  }
}, Ga = /* @__PURE__ */ v(qa, [["render", Ua]]), Xa = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  WAccordion: Ge,
  WAlert: Qe,
  WApp: lt,
  WBadge: at,
  WBreadcrumbs: dt,
  WButton: yt,
  WCard: _t,
  WCheckbox: xt,
  WCheckboxes: Et,
  WConfirm: Wt,
  WDatePicker: Dt,
  WDialog: jt,
  WDivider: Xt,
  WDrawer: el,
  WFlex: il,
  WForm: nl,
  WFormElement: ul,
  WGrid: pl,
  WIcon: gl,
  WImage: vl,
  WInput: xl,
  WList: zl,
  WMenu: Nl,
  WNotification: Kl,
  WOverlay: Hl,
  WParallax: Gl,
  WProgress: li,
  WRadio: ui,
  WRadios: fi,
  WRating: wi,
  WScrollbar: Ci,
  WSelect: Pi,
  WSlider: qi,
  WSpinner: Ji,
  WSteps: es,
  WSwitch: rs,
  WTabs: vs,
  WTable: Js,
  WTag: ta,
  WTextarea: ra,
  WTimeline: pa,
  WToolbar: ga,
  WTooltip: wa,
  WTransitionBounce: _a,
  WTransitionExpand: Sa,
  WTransitionFade: Ia,
  WTransitionScale: Ta,
  WTransitionScaleFade: Oa,
  WTransitionSlide: Ma,
  WTransitionSlideFade: Aa,
  WTransitionTwist: Fa,
  WTree: Ga
}, Symbol.toStringTag, { value: "Module" })), Ya = A.install;
A.install = (e, t = {}) => Ya.call(A, e, { components: Xa, ...t });
export {
  A as default
};
